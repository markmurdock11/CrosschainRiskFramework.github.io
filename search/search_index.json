{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Risk is the measure of the extent to which an entity is threatened by potential circumstances or events, and is typically a function of (i) the adverse impacts that would arise if the circumstance or event occurs, and (ii) the likelihood of occurrence. [NIST - National Institute of Standards and Technology] This document provides a high-level systematic overview of the security risks in cross-chain protocols by identifying, classifying, and analyzing the elements of risk inherent in the design, implementation and operation of such infrastructure. In addition, it profers a set of risk-controls and best practices to mitigate the likelihood and magnitude of various risks. While this document offers a general toolkit for reasoning about cross-chain protocols, it does not directly analyse individual protocols. Crosschain Communication Protocols Working definition : ... Modalities of Cross-chain Communication : ... Asset Exchange Asset Transfer General Purpose Communication: Security Challenges At its essence, cross-chain communications create dependency relationships between two or more networks. Such dependency relationships typically involve state change in one network driving state change in another. These relationships can be unidirectional or bidirectional , transient or persistent . The goal of cross-chain protocols is to enable and guarantee the integrity of these dependencies. To this end, given two networks, a source network and a destination network, where the state in the destination network is dependent on the state in the source network, cross-chain protocols must satisfy the following core properties: only states that are valid in the canonical ledger of the source network are communicated to the destination all relevant state transitions in the source network are relayed to the destination network in a timely manner any invariants that emerge from the cross-chain interactions are always preserved e.g. total supply of wrapped asset in the destination matches supply of underlying native asset in the source. TBA - note about the size scale and magnitude of hacks - challenges in systematically reasoning about the Security and risk in this space Purpose and Scope of this Framework","title":"Home"},{"location":"#introduction","text":"Risk is the measure of the extent to which an entity is threatened by potential circumstances or events, and is typically a function of (i) the adverse impacts that would arise if the circumstance or event occurs, and (ii) the likelihood of occurrence. [NIST - National Institute of Standards and Technology] This document provides a high-level systematic overview of the security risks in cross-chain protocols by identifying, classifying, and analyzing the elements of risk inherent in the design, implementation and operation of such infrastructure. In addition, it profers a set of risk-controls and best practices to mitigate the likelihood and magnitude of various risks. While this document offers a general toolkit for reasoning about cross-chain protocols, it does not directly analyse individual protocols.","title":"Introduction"},{"location":"#crosschain-communication-protocols","text":"Working definition : ... Modalities of Cross-chain Communication : ... Asset Exchange Asset Transfer General Purpose Communication:","title":"Crosschain Communication Protocols"},{"location":"#security-challenges","text":"At its essence, cross-chain communications create dependency relationships between two or more networks. Such dependency relationships typically involve state change in one network driving state change in another. These relationships can be unidirectional or bidirectional , transient or persistent . The goal of cross-chain protocols is to enable and guarantee the integrity of these dependencies. To this end, given two networks, a source network and a destination network, where the state in the destination network is dependent on the state in the source network, cross-chain protocols must satisfy the following core properties: only states that are valid in the canonical ledger of the source network are communicated to the destination all relevant state transitions in the source network are relayed to the destination network in a timely manner any invariants that emerge from the cross-chain interactions are always preserved e.g. total supply of wrapped asset in the destination matches supply of underlying native asset in the source. TBA - note about the size scale and magnitude of hacks - challenges in systematically reasoning about the Security and risk in this space","title":"Security Challenges"},{"location":"#purpose-and-scope-of-this-framework","text":"","title":"Purpose and Scope of this Framework"},{"location":"authors/authors/","text":"Authors The authors of the content on this website are listed below in alphabetical order. Please add yourself to the list as part of any pull-request. The initial commits by Peter Robinson were based on a Google Doc co-authored by Ermyas Abebe and Peter Robinson. Name Preferred contact method Links Arjun Chand Telegram Ermyas Abebe Telegram Mark Murdock Telegram Max Klenk Telegram Peter Robinson Telegram Vaibhav Chellani Telegram","title":"Authors"},{"location":"authors/authors/#authors","text":"The authors of the content on this website are listed below in alphabetical order. Please add yourself to the list as part of any pull-request. The initial commits by Peter Robinson were based on a Google Doc co-authored by Ermyas Abebe and Peter Robinson. Name Preferred contact method Links Arjun Chand Telegram Ermyas Abebe Telegram Mark Murdock Telegram Max Klenk Telegram Peter Robinson Telegram Vaibhav Chellani Telegram","title":"Authors"},{"location":"authors/code-of-conduct/","text":"Code of Conduct The Crosschain Risk Framework community consists of its online presence in this website and associated GitHub repository. These outlets are managed by the Crosschain Risk Framework Management Committee, whose members are listed in the Management Committee section of this site. We strive to be an open and inclusive community where anyone can contribute. Contributions should be judged on their own merits; we don\u2019t care about your gender identity, race, political beliefs, age, or similar attributes. If we see that one or more members of the community are generally abusive, harassing others, or seem to be trying to intimidate them into leaving the community, we will first ask those who are doing so to take a break from participation for a while. If you see any evidence of such activity, please let us know by contacting the Management Committee via Telegram.","title":"Code of conduct"},{"location":"authors/code-of-conduct/#code-of-conduct","text":"The Crosschain Risk Framework community consists of its online presence in this website and associated GitHub repository. These outlets are managed by the Crosschain Risk Framework Management Committee, whose members are listed in the Management Committee section of this site. We strive to be an open and inclusive community where anyone can contribute. Contributions should be judged on their own merits; we don\u2019t care about your gender identity, race, political beliefs, age, or similar attributes. If we see that one or more members of the community are generally abusive, harassing others, or seem to be trying to intimidate them into leaving the community, we will first ask those who are doing so to take a break from participation for a while. If you see any evidence of such activity, please let us know by contacting the Management Committee via Telegram.","title":"Code of Conduct"},{"location":"authors/committee/","text":"Management Committee The management committee for this website / repo is shown below. Please use Telegram to contact them. Arjun Chand Ermyas Abebe Mark Murdock Max Klenk Peter Robinson Vaibhav Chellani","title":"Committee"},{"location":"authors/committee/#management-committee","text":"The management committee for this website / repo is shown below. Please use Telegram to contact them. Arjun Chand Ermyas Abebe Mark Murdock Max Klenk Peter Robinson Vaibhav Chellani","title":"Management Committee"},{"location":"authors/contributing/","text":"How to Contribute Development is done on GitHub in the https://github.com/CrosschainRiskFramework/CrosschainRiskFramework.github.io repository. To add content, request new features or report issues, please open an issue on GitHub. To submit a patch, please open a pull request on GitHub. If you are thinking of making a large contribution, open an issue for it before starting work, to get comments from the community. Someone may be already working on the same thing, or there may be reasons why that feature isn't implemented. To make it easier to review and accept your pull request, please follow these guidelines: Anything other than a trivial contribution requires a Contributor License Agreement (CLA) , giving us permission to use your code. If your contribution is too small to require a CLA (e.g. fixing a spelling mistake), place the text \"CLA: trivial\" on a line by itself separated by an empty line from the rest of the commit message. It is not sufficient to only place the text in the GitHub pull request description. To amend a missing \"CLA: trivial\" line after submission, do the following: git commit --amend [add the line, save and quit the editor] git push -f Patches should be as current as possible; expect to have to rebase often. We do not accept merge commits, you will have to remove them (usually by rebasing) before it will be acceptable. Clean builds via GitHub Actions are required, and they are started automatically whenever a PR is created or updated.","title":"Contributing"},{"location":"authors/contributing/#how-to-contribute","text":"Development is done on GitHub in the https://github.com/CrosschainRiskFramework/CrosschainRiskFramework.github.io repository. To add content, request new features or report issues, please open an issue on GitHub. To submit a patch, please open a pull request on GitHub. If you are thinking of making a large contribution, open an issue for it before starting work, to get comments from the community. Someone may be already working on the same thing, or there may be reasons why that feature isn't implemented. To make it easier to review and accept your pull request, please follow these guidelines: Anything other than a trivial contribution requires a Contributor License Agreement (CLA) , giving us permission to use your code. If your contribution is too small to require a CLA (e.g. fixing a spelling mistake), place the text \"CLA: trivial\" on a line by itself separated by an empty line from the rest of the commit message. It is not sufficient to only place the text in the GitHub pull request description. To amend a missing \"CLA: trivial\" line after submission, do the following: git commit --amend [add the line, save and quit the editor] git push -f Patches should be as current as possible; expect to have to rebase often. We do not accept merge commits, you will have to remove them (usually by rebasing) before it will be acceptable. Clean builds via GitHub Actions are required, and they are started automatically whenever a PR is created or updated.","title":"How to Contribute"},{"location":"authors/contributions/","text":"Authors and Contributing Authors The authors of the content on this website are listed below in alphabetical order. Please add yourself to the list as part of any pull-request. The initial commits by Peter Robinson were based on a Google Doc co-authored by Ermyas Abebe and Peter Robinson. Name Preferred contact method Links Arjun Chand Telegram Ermyas Abebe Telegram Mark Murdock Telegram Max Klenk Telegram Peter Robinson Telegram Vaibhav Chellani Telegram Management Committee The management committee for this website / repo is shown below. Please use Telegram to contact them. Arjun Chand Ermyas Abebe Mark Murdock Max Klenk Peter Robinson Vaibhav Chellani Code of Conduct The Crosschain Risk Framework community consists of its online presence in this website and associated GitHub repository. These outlets are managed by the Crosschain Risk Framework Management Committee, whose members are listed in the Management Committee section of this site. We strive to be an open and inclusive community where anyone can contribute. Contributions should be judged on their own merits; we don\u2019t care about your gender identity, race, political beliefs, age, or similar attributes. If we see that one or more members of the community are generally abusive, harassing others, or seem to be trying to intimidate them into leaving the community, we will first ask those who are doing so to take a break from participation for a while. If you see any evidence of such activity, please let us know by contacting the Management Committee via Telegram. How to Contribute Development is done on GitHub in the https://github.com/CrosschainRiskFramework/CrosschainRiskFramework.github.io repository. To add content, request new features or report issues, please open an issue on GitHub. To submit a patch, please open a pull request on GitHub. If you are thinking of making a large contribution, open an issue for it before starting work, to get comments from the community. Someone may be already working on the same thing, or there may be reasons why that feature isn't implemented. To make it easier to review and accept your pull request, please follow these guidelines: Anything other than a trivial contribution requires a Contributor License Agreement (CLA) , giving us permission to use your code. If your contribution is too small to require a CLA (e.g. fixing a spelling mistake), place the text \"CLA: trivial\" on a line by itself separated by an empty line from the rest of the commit message. It is not sufficient to only place the text in the GitHub pull request description. To amend a missing \"CLA: trivial\" line after submission, do the following: git commit --amend [add the line, save and quit the editor] git push -f Patches should be as current as possible; expect to have to rebase often. We do not accept merge commits, you will have to remove them (usually by rebasing) before it will be acceptable. Clean builds via GitHub Actions are required, and they are started automatically whenever a PR is created or updated.","title":"Contributions"},{"location":"authors/contributions/#authors-and-contributing","text":"","title":"Authors and Contributing"},{"location":"authors/contributions/#authors","text":"The authors of the content on this website are listed below in alphabetical order. Please add yourself to the list as part of any pull-request. The initial commits by Peter Robinson were based on a Google Doc co-authored by Ermyas Abebe and Peter Robinson. Name Preferred contact method Links Arjun Chand Telegram Ermyas Abebe Telegram Mark Murdock Telegram Max Klenk Telegram Peter Robinson Telegram Vaibhav Chellani Telegram","title":"Authors"},{"location":"authors/contributions/#management-committee","text":"The management committee for this website / repo is shown below. Please use Telegram to contact them. Arjun Chand Ermyas Abebe Mark Murdock Max Klenk Peter Robinson Vaibhav Chellani","title":"Management Committee"},{"location":"authors/contributions/#code-of-conduct","text":"The Crosschain Risk Framework community consists of its online presence in this website and associated GitHub repository. These outlets are managed by the Crosschain Risk Framework Management Committee, whose members are listed in the Management Committee section of this site. We strive to be an open and inclusive community where anyone can contribute. Contributions should be judged on their own merits; we don\u2019t care about your gender identity, race, political beliefs, age, or similar attributes. If we see that one or more members of the community are generally abusive, harassing others, or seem to be trying to intimidate them into leaving the community, we will first ask those who are doing so to take a break from participation for a while. If you see any evidence of such activity, please let us know by contacting the Management Committee via Telegram.","title":"Code of Conduct"},{"location":"authors/contributions/#how-to-contribute","text":"Development is done on GitHub in the https://github.com/CrosschainRiskFramework/CrosschainRiskFramework.github.io repository. To add content, request new features or report issues, please open an issue on GitHub. To submit a patch, please open a pull request on GitHub. If you are thinking of making a large contribution, open an issue for it before starting work, to get comments from the community. Someone may be already working on the same thing, or there may be reasons why that feature isn't implemented. To make it easier to review and accept your pull request, please follow these guidelines: Anything other than a trivial contribution requires a Contributor License Agreement (CLA) , giving us permission to use your code. If your contribution is too small to require a CLA (e.g. fixing a spelling mistake), place the text \"CLA: trivial\" on a line by itself separated by an empty line from the rest of the commit message. It is not sufficient to only place the text in the GitHub pull request description. To amend a missing \"CLA: trivial\" line after submission, do the following: git commit --amend [add the line, save and quit the editor] git push -f Patches should be as current as possible; expect to have to rebase often. We do not accept merge commits, you will have to remove them (usually by rebasing) before it will be acceptable. Clean builds via GitHub Actions are required, and they are started automatically whenever a PR is created or updated.","title":"How to Contribute"},{"location":"comparison/comparison/","text":"Comparison Nothing here yet.","title":"Comparison"},{"location":"comparison/comparison/#comparison","text":"Nothing here yet.","title":"Comparison"},{"location":"faq/faq/","text":"Frequently Asked Questions Crosschain, Cross-chain, or CrossChain? Blockchain is written blockchain and not BlockChain or block-chain. To be consistent, we feel communications across blockchains should be known as crosschain. How can I contribute? Please submit a pull request to the repo behind this website","title":"FAQ"},{"location":"faq/faq/#frequently-asked-questions","text":"","title":"Frequently Asked Questions"},{"location":"faq/faq/#crosschain-cross-chain-or-crosschain","text":"Blockchain is written blockchain and not BlockChain or block-chain. To be consistent, we feel communications across blockchains should be known as crosschain.","title":"Crosschain, Cross-chain, or CrossChain?"},{"location":"faq/faq/#how-can-i-contribute","text":"Please submit a pull request to the repo behind this website","title":"How can I contribute?"},{"location":"framework/01intro/introduction/","text":"Introduction Risk is the measure of the extent to which an entity is threatened by potential circumstances or events, and is typically a function of (i) the adverse impacts that would arise if the circumstance or event occurs, and (ii) the likelihood of occurrence. [NIST - National Institute of Standards and Technology] This document provides a high-level systematic overview of the security risks in cross-chain protocols by identifying, classifying, and analyzing the elements of risk inherent in the design, implementation and operation of such infrastructure. In addition, it profers a set of risk-controls and best practices to mitigate the likelihood and magnitude of various risks. While this document offers a general toolkit for reasoning about cross-chain protocols, it does not directly analyse individual protocols. Crosschain Communication Protocols Working definition : ... Modalities of Cross-chain Communication : ... Asset Exchange Asset Transfer General Purpose Communication: Security Challenges At its essence, cross-chain communications create dependency relationships between two or more networks. Such dependency relationships typically involve state change in one network driving state change in another. These relationships can be unidirectional or bidirectional , transient or persistent . The goal of cross-chain protocols is to enable and guarantee the integrity of these dependencies. To this end, given two networks, a source network and a destination network, where the state in the destination network is dependent on the state in the source network, cross-chain protocols must satisfy the following core properties: only states that are valid in the canonical ledger of the source network are communicated to the destination all relevant state transitions in the source network are relayed to the destination network in a timely manner any invariants that emerge from the cross-chain interactions are always preserved e.g. total supply of wrapped asset in the destination matches supply of underlying native asset in the source. TBA - note about the size scale and magnitude of hacks - challenges in systematically reasoning about the Security and risk in this space Purpose and Scope of this Framework","title":"Introduction"},{"location":"framework/01intro/introduction/#introduction","text":"Risk is the measure of the extent to which an entity is threatened by potential circumstances or events, and is typically a function of (i) the adverse impacts that would arise if the circumstance or event occurs, and (ii) the likelihood of occurrence. [NIST - National Institute of Standards and Technology] This document provides a high-level systematic overview of the security risks in cross-chain protocols by identifying, classifying, and analyzing the elements of risk inherent in the design, implementation and operation of such infrastructure. In addition, it profers a set of risk-controls and best practices to mitigate the likelihood and magnitude of various risks. While this document offers a general toolkit for reasoning about cross-chain protocols, it does not directly analyse individual protocols.","title":"Introduction"},{"location":"framework/01intro/introduction/#crosschain-communication-protocols","text":"Working definition : ... Modalities of Cross-chain Communication : ... Asset Exchange Asset Transfer General Purpose Communication:","title":"Crosschain Communication Protocols"},{"location":"framework/01intro/introduction/#security-challenges","text":"At its essence, cross-chain communications create dependency relationships between two or more networks. Such dependency relationships typically involve state change in one network driving state change in another. These relationships can be unidirectional or bidirectional , transient or persistent . The goal of cross-chain protocols is to enable and guarantee the integrity of these dependencies. To this end, given two networks, a source network and a destination network, where the state in the destination network is dependent on the state in the source network, cross-chain protocols must satisfy the following core properties: only states that are valid in the canonical ledger of the source network are communicated to the destination all relevant state transitions in the source network are relayed to the destination network in a timely manner any invariants that emerge from the cross-chain interactions are always preserved e.g. total supply of wrapped asset in the destination matches supply of underlying native asset in the source. TBA - note about the size scale and magnitude of hacks - challenges in systematically reasoning about the Security and risk in this space","title":"Security Challenges"},{"location":"framework/01intro/introduction/#purpose-and-scope-of-this-framework","text":"","title":"Purpose and Scope of this Framework"},{"location":"framework/10stakeholders/stakeholders/","text":"Stakeholders Cross-chain protocols can have several distinct stakeholders with direct or indirect involvement in the system. These stakeholders can be individuals, groups, or organizations and have different roles, constraints, goals, and incentives. Consequently, the types and magnitudes of risk borne by each stakeholder might vary considerably across protocols. Understanding the dynamics of cross-chain risk from the perspective of different actors will aid in a more sound analysis. To this end, we identify four types of stakeholders in cross-chain protocols: Users Users are the primary customers of the service offered by a cross-chain protocol. They interact with the system directly to exchange assets or transfer data and value across chains. A user might directly interface with a cross-chain protocol (e.g., token bridge) or through an intermediary applications. A user's involvement with a protocol is typically short-lived and ends once their cross-chain transaction has settled. Liquidity Provider In a cross-chain asset exchange, a liquidity provider is the counter-party to a user. For a fee, it exchanges its assets in one network for a user's assets in another. It might compete with other liquidity providers to offer this service and have defined performance and service-level constraints in its operations. Liquidity providers typically maintain longer exposure to the risks of a protocol and might also need to account for market-related risks beyond protocol risks. Bridge Liability Holder A common approach to enabling the transfer of assets from one chain to another is through a lock-and-mint mechanism, in which cross-chain protocols lock assets on one network and mint corresponding synthetic assets on another. These synthetic assets are, in effect, a liability of the bridge that can later be redeemed for the underlying asset. We refer to any entity that holds such synthetic assets as a bridge liability holder . A bridge liability holder might or might not be a user of a cross-chain protocol. More importantly, such stakeholders are exposed to the idiosyncratic risks of a protocol so long as they hold the asset. If a protocol's underlying assets are compromised the corresponding synthetic assets could lose some or all of their value. Bridge Validators Cross-chain protocols typically coordinate several off-chain systems and actors that collectively ensure the integrity of state communication across chains. Such entities might be responsible for verifying, validating, proving, attesting, or relaying cross-chain states. How different protocols coordinate and incentivize such actors to offer specific security properties varies significantly. However, in general, bridge validators are the primary entities that ensure the security and continued operation of a cross-chain protocols and thus represent a significant source of potential risk to the overall system. Bridge Operators Bridge operators are actors that can update or reconfigure key elements of a cross-chain protocol (e.g. upgrading on-chain smart contracts, updating validator registries). How many bridge operators a protocol has, what they are allowed to change and what policies govern their actions can significantly influence the risk profile of a protocol and varies considerably across projects. Bridge Developers Bridge developers design, build, test, and maintain the codebase behind a cross-chain protocol. Given the complex nature of such systems, the possibility of introducing bugs and vulnerabilities is considerable. The experience and competence of bridge developers and the policies and procedures they put in place to address incidents, significantly influence the level of implementation risk of a protocol.","title":"Stakeholders"},{"location":"framework/10stakeholders/stakeholders/#stakeholders","text":"Cross-chain protocols can have several distinct stakeholders with direct or indirect involvement in the system. These stakeholders can be individuals, groups, or organizations and have different roles, constraints, goals, and incentives. Consequently, the types and magnitudes of risk borne by each stakeholder might vary considerably across protocols. Understanding the dynamics of cross-chain risk from the perspective of different actors will aid in a more sound analysis. To this end, we identify four types of stakeholders in cross-chain protocols:","title":"Stakeholders"},{"location":"framework/10stakeholders/stakeholders/#users","text":"Users are the primary customers of the service offered by a cross-chain protocol. They interact with the system directly to exchange assets or transfer data and value across chains. A user might directly interface with a cross-chain protocol (e.g., token bridge) or through an intermediary applications. A user's involvement with a protocol is typically short-lived and ends once their cross-chain transaction has settled.","title":"Users"},{"location":"framework/10stakeholders/stakeholders/#liquidity-provider","text":"In a cross-chain asset exchange, a liquidity provider is the counter-party to a user. For a fee, it exchanges its assets in one network for a user's assets in another. It might compete with other liquidity providers to offer this service and have defined performance and service-level constraints in its operations. Liquidity providers typically maintain longer exposure to the risks of a protocol and might also need to account for market-related risks beyond protocol risks.","title":"Liquidity Provider"},{"location":"framework/10stakeholders/stakeholders/#bridge-liability-holder","text":"A common approach to enabling the transfer of assets from one chain to another is through a lock-and-mint mechanism, in which cross-chain protocols lock assets on one network and mint corresponding synthetic assets on another. These synthetic assets are, in effect, a liability of the bridge that can later be redeemed for the underlying asset. We refer to any entity that holds such synthetic assets as a bridge liability holder . A bridge liability holder might or might not be a user of a cross-chain protocol. More importantly, such stakeholders are exposed to the idiosyncratic risks of a protocol so long as they hold the asset. If a protocol's underlying assets are compromised the corresponding synthetic assets could lose some or all of their value.","title":"Bridge Liability Holder"},{"location":"framework/10stakeholders/stakeholders/#bridge-validators","text":"Cross-chain protocols typically coordinate several off-chain systems and actors that collectively ensure the integrity of state communication across chains. Such entities might be responsible for verifying, validating, proving, attesting, or relaying cross-chain states. How different protocols coordinate and incentivize such actors to offer specific security properties varies significantly. However, in general, bridge validators are the primary entities that ensure the security and continued operation of a cross-chain protocols and thus represent a significant source of potential risk to the overall system.","title":"Bridge Validators"},{"location":"framework/10stakeholders/stakeholders/#bridge-operators","text":"Bridge operators are actors that can update or reconfigure key elements of a cross-chain protocol (e.g. upgrading on-chain smart contracts, updating validator registries). How many bridge operators a protocol has, what they are allowed to change and what policies govern their actions can significantly influence the risk profile of a protocol and varies considerably across projects.","title":"Bridge Operators"},{"location":"framework/10stakeholders/stakeholders/#bridge-developers","text":"Bridge developers design, build, test, and maintain the codebase behind a cross-chain protocol. Given the complex nature of such systems, the possibility of introducing bugs and vulnerabilities is considerable. The experience and competence of bridge developers and the policies and procedures they put in place to address incidents, significantly influence the level of implementation risk of a protocol.","title":"Bridge Developers"},{"location":"framework/20categories/categories-of-risk/","text":"Categories of Risk Cross-chain protocols are generally complex systems that are exposed to numerous sources of risk. Classifying these risks enables better reasoning about the inherent limits and challenges of protocols and the considerations and mitigations of different risk factors. To this end, this section identifies four key categories of risk in cross-chain communication: Network Consensus Risk: One of the core security assumptions of cross-chain communication is that the state communicated from one network to another is valid according to the consensus rules of the underlying network. Failures in the safety or liveness properties of an underlying network can thus risk creating inconsistent state changes across chains that cannot be reconciled. Such risks are often beyond the control boundary of cross-chain infrastructure and likely represent a fundamental security limitation to bridging across independent sovereign chains. The impact of a failure of this type would simultaneously affect all bridges exposed to the underlying faulty network. However, risk controls can be enacted to limit the magnitude of such failures (e.g. containing and isolating the impact of failures in any single network). Protocol Architecture Risk: As discussed in the Introduction , cross-chain protocols can be viewed through a layered architecture. The design assumptions and constraints under which protocols at each layer guarantee relevant security properties can be a source of significant risk. For instance, at the messaging layer, architectures that introduce new trusted parties often offer weaker guarantees than those that solely rely on the security of the underlying networks. Protocol Implementation Risk: Building cross-chain protocols involves creating complex components (on-chain, off-chain) while accounting for the peculiarities and pitfalls of different programming languages, virtual machines, and runtime environments. Inevitably, such complexity increases the likelihood of bugs and vulnerabilities. This type of risk has thus far been the most common cause of bridge hacks witnessed over the last couple of years. Protocol Operation Risk: The operation of a cross-chain bridge involves the management of various components, potentially by distinct actors. Such activities could include the upgrade and management of bridge smart contracts and the operation of various off-chain systems (e.g. external validator nodes). Failures and oversights in these operational activities can present a significant source of risk to protocols. Having robust, secure, decentralized, and transparent mechanisms and processes for managing such systems is crucial to ensuring the security of cross-chain bridges. The following sections review each of these areas of risk in more detail. Network Consensus Risk Cross-chain protocols enable the coordination of state changes across networks. This typically requires sending state information from a source network to one or more destination networks and performing consequent state changes. A fundamental assumption in this process is that: a) states in the source network are valid and final according to its consensus rules, and b) the underlying network can process all transactions in a timely manner. From the perspective of risk in cross-chain protocols, there are at least three considerations relating to these assumptions: 1. Protocols should only communicate states that have been finalized in the source network 1. Protocol security should be resilient to network liveness failures 1. Protocols should mitigate the impact of network safety violations Transaction Finality A transaction that is irrevocably included in a ledger is considered final . How finality is achieved varies across networks and can either be probabilistic or deterministic . Networks with deterministic finality offer absolute assurance about the state of a network after some time. In contrast, probabilistic models offer only degrees of confidence, with increasing assurance attained over time. For deterministic models, finality could be instantly achieved after a single block or eventually after several blocks. Networks with slower finality times increase latency in cross-chain communication, which impacts the customer experience. However, cross-chain protocols must ensure that the finality of a given state is achieved before relaying the state across chains. Cross-chain protocols, which optimize for performance and relay information across chains without sufficiently waiting for finality, risk creating inconsistencies across networks and the possible loss of a party's funds. Network Liveness Failures Some cross-chain protocols rely considerably on the underlying networks processing transactions within a given period. For instance, protocols might assume that cross-chain messages or fraud proofs can be submitted within a time window. However, some consensus protocols explicitly trade-off liveness for safety under certain conditions. That is, a network can halt for extended periods in the event that a portion of its validators are offline or unreachable. Cross-chain protocols must carefully account for these scenarios in their design. Network Safety Violations A fundamental and systematic problem for cross-chain protocols across sovereign networks is if the ledger of the underlying network undergoes significant reorganizations and reversions. This could result from active network attacks (e.g., 51% attack), hard forks, or bugs in protocol implementations. The likelihood of such failures is higher in chains with fewer validators, lower economic security, or new consensus protocols. Such risks are often beyond the control boundary of cross-chain infrastructure and affect all cross-chain protocols connected to a network simultaneously. For cross-chain protocols spanning independent networks, this likely represents a fundamental security limitation to the security guarantees that such protocols can offer. However, cross-chain protocols can reduce the impact of such failure by limiting contagion to other chains. If a consensus failure in one network can cascade to affect all other chains, then the security of a bridge is dependent on its weakest link. Additionally, cross-chain protocol builders should conduct adequate due diligence on the security and decentralisation properties of the networks they integrate. Protocol Architecture Risk Protocol architecture risks relate to the design of the cross-chain communications protocol. The major consideration is the communications protocol trust assumptions. However, other more detailed design considerations can impose important risks. Messaging Protocol A cross-chain messaging protocol is responsible for communicating state transition events from applications on one network to applications on another. It should guarantee that these events are valid according to the canonical ledger state of the source network (safety) and ensure that all relevant state transitions are eventually communicated to their destination network (liveness). From the perspective of safety, an ideal message protocol construction would introduce no additional trust assumptions beyond what is assumed about the networks themselves. This would involve a destination network independently being able to verify that a) a state transition that resulted in a given message is valid according to the state transition rules of the source network and b) that the message has been finalized on the network as per the network consensus rules of the source. Full-client verification-based bridging A full-client verification bridge involves one network validating all state transitions and consensus rules of another network, in effect achieving both properties stated above. This type of bridging retains the strongest guarantees of the underlying networks and does not introduce any additional trust assumption. However, this approach introduces significant complexities in implementation and is hard to scale across diverse ecosystems. To date, these are employed only by layer 2 chains (optimistic and ZK rollups), and not across independent L1 networks. Light-client verification-based bridging In a light-client verification bridge a destination network validates that a given block header (or state aggregate), from a source network, is valid only according to the consensus rules of a network, without executing and verifying individual state transitions. While light clients offer less security compared to full-client-based approaches, they too do not introduce additional trust assumptions, beyond those of the underlying networks. Different network protocols have different light-client protocols with differing levels of security assumptions and guarantees. The security guarantees of such bridges are subject to these limitations. We distinguish between two categories of light-client bridges: On-chain light-client protocol implementations: these involve implementing the light-client protocol as a smart contract on another. Typically block headers are relayed from the source network to the smart contract on a destination network for validation. An arbitrary state in a source network can then be proved against a validated block header stored by the smart contract on the destination network. Implementing, operating, and maintaining light-client-based bridges can be difficult, expensive, or infeasible, making this difficult to apply across diverse ecosystems. Validity Proof Bridges (aka ZK bridges) Third-party attestation reliant bridging While the above approaches offer better security guarantees because they remove the need for additional trust assumptions, they are difficult to implement and operate across diverse ecosystems. Hence, most cross-chain protocols introduce additional sources of trust in the form of third-party attestors. In general, such models rely on trusted third parties serving as oracles that attest and relay state events occurring in a source network, to a destination network. The security models of such bridges rely on the honest behavior of such attestors, either because they are game theoretically incentivized or have their reputation at stake. We generally distinguish between three categories of such bridges, based on the security model they employ. Proof-of-Authority approaches: rely on well-known legal entities running nodes that attest to the validity of messages from one network to another. Such bridges assume that a) parties are strongly incentivized to maintain their reputation and would thus not misbehave and b) that in the event of misbehavior legal recourse could be pursued against such entities. Considerations: How many such entities are employed by the network? What are the specific honesty threshold assumptions for guaranteeing safety and liveness? What are the specific characteristics of the cryptographic schemes employed? How reputable are such entities? What is the true cost of reputational damage for such entities? What is the market cap of such entities? Do such entities have competing interests with users of this bridge? e.g. Trading firms that might benefit from cross-domain MEV? How do the above disincentives to misbehavior compare against the TVL or total volume transacted by layers atop the messaging bridge? In what jurisdictions are the entities domiciled? Can these entities be coerced by regulations to censor transactions? Proof-of-Stake approaches: rely on a set of parties having a financial stake in honestly relaying valid state information from one network to another. Considerations: How many such entities are employed by the network? What are the specific honesty threshold assumptions for guaranteeing safety and liveness? What are the specific characteristics of the cryptographic schemes employed? How is the stake distributed across networks? (i.e. concentrated amongst few parties vs diffuse across many parties) What exactly is staked by validators? Is it a bridge-specific token? What are the dynamics that drive the value of such tokens? What is the cost of bribing or corrupting a threshold of such validators to violate safety or liveness? How does the bridge adapt to active misbehavior by a portion of the validators? Optimistic approaches - honest minority (but incentive alignment that such a minority exists) A number of protocols employ a hybrid approach, that utilizes different approaches for different legs of the cross-chain interaction. Coordination Protocols Atomicity e.g. GPACT Token Bridges Token bridges are protocols that enable the transfer of assets from one network to another. This can be enacted using either a lock-and-mint or a burn-and-mint mechanism. In both cases, the protocol involves minting synthetic assets on a destination that are claimable for a corresponding amount of underlying assets at a later time. The invariant such protocols must preserve is that the value of an asset only resides in one place at a given time and that the total supply of synthetic assets matches the total underlying. Scenarios in which either locked assets on a source network are stolen or synthetic assets are arbitrarily minted on a destination network, break these invariants. This creates a perpetual risk for token holders of synthetic assets, in which these assets could become worthless in the event of such failures. Moreover, lock-and-mint token bridges in particular create honey pots that make them an ideal target for malicious actors. A significant portion of bridge hacks over the last couple of years has involved this source of risk. Liquidity Networks Note: include HTLCs as a possible design approach Protocol Implementation Risk The design of contracts and code implementation changes the risk profile of the project. This section discusses design features and then works through software development implementation risks. Mixing of Control and Data Plane The terms Control Plane and Data Plane come from networking [ Wikipedia ]. In the context of networking, the Control Plane configures the network topology and routing tables, and the Data Plane is the information that is communicated across the network. In the context of computing, the Control Plane is the configuration of the system, and the Data Plane is the data processing. Functions in smart contracts can be ones that control the configuration of the contract. These can be thought of as Control Plane functions. For example, a function to pause the contract is a Control Plane function. Data Plane functions are functions that process data. For example, a function to mint some tokens is a Data Plane function. Poor project design can result in smart contract functions that contain both Control Plane and Data Plane logic. Mixing these two planes in the one function dramatically increases the risk of the project. An attacker may be able to compromise the Data Plane part of a mixed processing function, and then use that to change the configuration of the project, accessing the Control Plane part of the mixed function. This can lead to the attacker having the ability to control aspects of the project such as minting tokens. Example As example of this type of issue being exploited is the August 2021 PolyNetwork issue . The PolyNetwork code was written such that its EthCrossChainManager contract was the owner of the EthCrossChainData contract. The EthCrossChainData contract held important information including the public keys used to verify crosschain requests. Doing this allows for function calls for EthCrossChainData to go via the EthCrossChainManager contract. Access from the EthCrossChainManager contract to the EthCrossChainData contract could be deemed part of the Control Plane. The EthCrossChainManager contract also had a function verifyHeaderAndExecuteTx that was used to process Data Plane requests. The attacker was able to create a carefully constructed call to verifyHeaderAndExecuteTx that allowed the Data Plane request to modify data in the EthCrossChainData , that ultimately led to the attacker being able to steal funds. The PolyNetwork code would not have been vulnerable to this type of attack if there had been a clear separation of Control Plane and Data Plane. For example, rather than doing updates to the EthCrossChainData contract via the EthCrossChainManager contract, updates could have been only allowed from an Externally Owned Account (EOA) or a MultiSig Wallet account. Ability to Pause Project All Data Plane functions should be pausable . For example, a bridge contract could have a function that could transfer coins based on actions on another blockchain. The ability to pause a function in a project allows administrators to stop functions from successfully executing. If there is a vulnerability that is being actively exploited in a project, having the ability to pause a function could stop the exploitation of the project midway through the attack. For Ethereum based projects, the OpenZeppelin project has an example contract Pausable.sol that can be used to implement pausing. Using this template, pausing a function becomes as simple as adding a modifier whenNotPaused . The code below shows how this would work in practice. contract Example is Pausable { function pause() external onlyOwner { _pause(); } function transfer( address _sender, address _tokenContract, address _recipient, uint256 _amount ) external whenNotPaused { // Only executed when not paused When analyzing whether a project can be paused, it is important to check whether all data processing functions can be paused, or just some parts of the project. Example For example, in August 2022 the Nomad Bridge had an issue (see Rekt for an analysis of the issue from people outside the team). An attacker was able to determine a methodology for stealing funds using the Replica contract's process() function. Depite most of the Data Plane processing functions in the project being pausable, the process() function was not. This meant that the attack was able to proceed without the administrators of the project being able to stop it. Role Based Access Control Role Based Access Control (RBAC) allows different entites to be responsible for different configuration actions. Systems that are managed by a single entity are inherently less secure than those with narrowly-scoped privileges for different entities and specific contexts. With contracts, this can be used to limit which accounts can execute which functions. For example, imagine a contract that operates as a crosschain bridge. It could have a role called PAUSER . This role could be required to call a function that enables pausing of the contract. Any transaction submitted by an account that did not have the PAUSER role would be reverted. Simplistic contracts might have a single role, OWNER , that can only be assigned to one account. For these contracts, the owner account is the only account that can submit transactions that call configuration functions without reverting. The greater degree of flexibility afforded by Role Based Access Control compared to simplistic OWNER style access control has security implications. For example, a contract might be able to mint new tokens, and thus have a MINTER role to control this action. Minting new tokens could change the tokenomics of the contract, and hence must only be executed if there is agreement between administrators. Access to this configuration action might be limited to a multi-signature wallet account. The same contract might have a PAUSER role that can be used to stop data processing within the contract. The action to pause the contract needs to occur as quickly as possible, to halt an in-progress attack. However, access to the role needs to be limited to trusted accounts, to prevent attackers causing a Denial of Service attack on the contract, by continually pausing the contract. Using a multi-signature wallet to control this action is not ideal, as multiple parties would need to work together to pause the contract, thus allowing attacks to continue longer than they otherwise would. In this situation, multiple trusted accounts could be granted PAUSER role. Any one of the accounts could then pause the contract. For a small project, when a contract is deployed, it might be tempting to use simplistic OWNER style access control. However, it is better to deploy a contract configured for fine grain Role Based Access Control, where all roles are initially assigned to the one account. In this way, as the project using the contract matures, new accounts can be granted roles and the original account's access can be revoked. It should be noted that the benefits of RBAC are only realised once access for different roles is allocated to additional accounts. For Ethereum based projects, the OpenZeppelin project has an example contract AccessControl.sol that can be used to implement Role Based Access Control. Using this template, checking an address has been granted a role becomes as simple as calling the function hasRole . The code below shows how this would work in practice. contract Example is Pausable, AccessControl { constructor() { _setupRole(DEFAULT_ADMIN_ROLE, msg.sender); _setupRole(PAUSER_ROLE, msg.sender); } function pause() external { require(hasRole(PAUSER_ROLE, msg.sender), \"Must have PAUSER role\"); _pause(); } } Upgradable TODO: This needs some thought. Upgrading can lead to rug-pulling, possibly by attackers who gain access to the address with upgrade privileges. However, code often has bugs. Additionally, new features can be added. Hence, the ability to upgrade is important. Are different upgrade mechanisms more and less risky? Transparent proxy Poor implementation where storage slots are mistakenly re-used has led to vulnerabilities. Deploy new contract and point front end at new contract. Non-transparent proxy with separate data contract. Ability to Ban Addresses Addresses may be associated with stolen funds. Tornado Cash was a project that had sanctions placed against it due to its association with stolen funds. Projects that have the ability to block these addresses, or freeze in-transit funds are more likely to avoid this type of regulatory risk. Well Known Platform More people are likely to be able to review and understand projects that are created in environments that they are familiar with. The majority of the blockchain developers in the world understand Ethereum and the Ethereum Virtual Machine (EVM). Hence, projects that use blockchains that support the EVM, or that are forks or Ethereum, are inherently less risky than projects that involve other blockchains. Well Known Smart Contract Programming Language More people are likely to be able to review and understand code that has been created in programming languages that they are familiar with. Solidity is the smart contract programming language known by most blockchain developers. Hence, projects that use Solidity are inherently less risky than projects that use other smart contract programming languages. Solidity Assembler can be used to implement complex features not available in standard Solidity. Assembler code is more complex than Solidity code and is more likely to contain bugs and have unexpected consequences. Open Source Code If the code is stored in a public Github repository, it allows people to review the code and the test system. If many people view the code, then it is likely that defects in the code will be found. Additionally, it allows for the assessment of such things as the number of tests. Some people argue that a private Github repository is more secure, believing that issues can be hidden from attackers. However, attackers who are sufficiently motivated often obtain access of private repository or to a copy of the code, and are then able to exploit any vulnerabilities. Not having the repository public then hinders white hat developers from helping, in the case of an attack. When using a public repository, it is important that issues that relate to vulnerabilities and code fixes for vulnerabilities are not put on the public repository before a release including the vulnerability fix has been deployed. Not doing this equates to publishing vulnerabilities that can be used to exploit the project. The approach that should be taken is to review and test the vulnerability fix using the private repo, deploy from the private repo, and the push the fix to the public repo. Code Auditing TODO: This section needs to be re-worked. Has the code been audited? Have the deployed version audited? A source of risk is that a version of the code has been audited, but that the code deployed has not been audited. Verified Code on Etherscan All deployed contracts should have the source code uploaded using the Etherscan verified code tool, or similar tools for other blockchains. Not being able to determine what code have been deployed reduces the trust stakeholders have in the project. Testing Code that is not tested is far more likely to contain bugs than code that has been tested. Comprehensive tests allow new features to be added without fear of breaking existing functionality. Hence, the more comprehensive the testing of the project, the less risky the project is. TODO: discuss continuous integration Formal Verification Formally verified code should prove that the code matches the specification. Hence, formal verification can not detect bugs in the design of the project. However, it will pick-up implementation bugs that testing might miss. Documentation More documentation makes a project easier to analyze. A lack of documentation can lead to confusion and issues being missed. Projects that have good documentation are easier to maintain. Types of documentation a good project should have are: Architecture document that includes the component and deployment architecture. Thread model that includes all parts of the project. Sequence diagrams for all major data flows. Test plan describing how the project will be tested. Smart contract code comments at the contract and function level. Off-chain code with comments at the class and method level. Test code with at least a class level comment. Secret Storage Most projects use cryptographic keys to operate the system. These keys could be stored in a network HSM or a hardware wallet, and not in a file on disk on a server. Product Development Maturity TODO: Software Development Lifecycle (SDLC) Protocol Operation Risk Operational Security TODO: Discuss security posture and how is applies. Ability to Pause If pausing is controlled by a multi-sig, then there is the risk that not enough parties can be gathered quickly enough to pause the project. Codebase Diversity Is there just one implementation, or have multiple parties implemented the protocol? Decentralization of Operations Is there a single operator of off-chain components, or are many parties involved? Security of off-chain systems TODO (e.g. validators) Standard security practices such as ISO27001 Vulnerability Response Plan Is there a vulnerability response plan? Is there a methodology for deploying an upgrade prior to committing code to a public github repo?","title":"Categories of Risk"},{"location":"framework/20categories/categories-of-risk/#categories-of-risk","text":"Cross-chain protocols are generally complex systems that are exposed to numerous sources of risk. Classifying these risks enables better reasoning about the inherent limits and challenges of protocols and the considerations and mitigations of different risk factors. To this end, this section identifies four key categories of risk in cross-chain communication: Network Consensus Risk: One of the core security assumptions of cross-chain communication is that the state communicated from one network to another is valid according to the consensus rules of the underlying network. Failures in the safety or liveness properties of an underlying network can thus risk creating inconsistent state changes across chains that cannot be reconciled. Such risks are often beyond the control boundary of cross-chain infrastructure and likely represent a fundamental security limitation to bridging across independent sovereign chains. The impact of a failure of this type would simultaneously affect all bridges exposed to the underlying faulty network. However, risk controls can be enacted to limit the magnitude of such failures (e.g. containing and isolating the impact of failures in any single network). Protocol Architecture Risk: As discussed in the Introduction , cross-chain protocols can be viewed through a layered architecture. The design assumptions and constraints under which protocols at each layer guarantee relevant security properties can be a source of significant risk. For instance, at the messaging layer, architectures that introduce new trusted parties often offer weaker guarantees than those that solely rely on the security of the underlying networks. Protocol Implementation Risk: Building cross-chain protocols involves creating complex components (on-chain, off-chain) while accounting for the peculiarities and pitfalls of different programming languages, virtual machines, and runtime environments. Inevitably, such complexity increases the likelihood of bugs and vulnerabilities. This type of risk has thus far been the most common cause of bridge hacks witnessed over the last couple of years. Protocol Operation Risk: The operation of a cross-chain bridge involves the management of various components, potentially by distinct actors. Such activities could include the upgrade and management of bridge smart contracts and the operation of various off-chain systems (e.g. external validator nodes). Failures and oversights in these operational activities can present a significant source of risk to protocols. Having robust, secure, decentralized, and transparent mechanisms and processes for managing such systems is crucial to ensuring the security of cross-chain bridges. The following sections review each of these areas of risk in more detail.","title":"Categories of Risk"},{"location":"framework/20categories/categories-of-risk/#network-consensus-risk","text":"Cross-chain protocols enable the coordination of state changes across networks. This typically requires sending state information from a source network to one or more destination networks and performing consequent state changes. A fundamental assumption in this process is that: a) states in the source network are valid and final according to its consensus rules, and b) the underlying network can process all transactions in a timely manner. From the perspective of risk in cross-chain protocols, there are at least three considerations relating to these assumptions: 1. Protocols should only communicate states that have been finalized in the source network 1. Protocol security should be resilient to network liveness failures 1. Protocols should mitigate the impact of network safety violations","title":"Network Consensus Risk"},{"location":"framework/20categories/categories-of-risk/#transaction-finality","text":"A transaction that is irrevocably included in a ledger is considered final . How finality is achieved varies across networks and can either be probabilistic or deterministic . Networks with deterministic finality offer absolute assurance about the state of a network after some time. In contrast, probabilistic models offer only degrees of confidence, with increasing assurance attained over time. For deterministic models, finality could be instantly achieved after a single block or eventually after several blocks. Networks with slower finality times increase latency in cross-chain communication, which impacts the customer experience. However, cross-chain protocols must ensure that the finality of a given state is achieved before relaying the state across chains. Cross-chain protocols, which optimize for performance and relay information across chains without sufficiently waiting for finality, risk creating inconsistencies across networks and the possible loss of a party's funds.","title":"Transaction Finality"},{"location":"framework/20categories/categories-of-risk/#network-liveness-failures","text":"Some cross-chain protocols rely considerably on the underlying networks processing transactions within a given period. For instance, protocols might assume that cross-chain messages or fraud proofs can be submitted within a time window. However, some consensus protocols explicitly trade-off liveness for safety under certain conditions. That is, a network can halt for extended periods in the event that a portion of its validators are offline or unreachable. Cross-chain protocols must carefully account for these scenarios in their design.","title":"Network Liveness Failures"},{"location":"framework/20categories/categories-of-risk/#network-safety-violations","text":"A fundamental and systematic problem for cross-chain protocols across sovereign networks is if the ledger of the underlying network undergoes significant reorganizations and reversions. This could result from active network attacks (e.g., 51% attack), hard forks, or bugs in protocol implementations. The likelihood of such failures is higher in chains with fewer validators, lower economic security, or new consensus protocols. Such risks are often beyond the control boundary of cross-chain infrastructure and affect all cross-chain protocols connected to a network simultaneously. For cross-chain protocols spanning independent networks, this likely represents a fundamental security limitation to the security guarantees that such protocols can offer. However, cross-chain protocols can reduce the impact of such failure by limiting contagion to other chains. If a consensus failure in one network can cascade to affect all other chains, then the security of a bridge is dependent on its weakest link. Additionally, cross-chain protocol builders should conduct adequate due diligence on the security and decentralisation properties of the networks they integrate.","title":"Network Safety Violations"},{"location":"framework/20categories/categories-of-risk/#protocol-architecture-risk","text":"Protocol architecture risks relate to the design of the cross-chain communications protocol. The major consideration is the communications protocol trust assumptions. However, other more detailed design considerations can impose important risks.","title":"Protocol Architecture Risk"},{"location":"framework/20categories/categories-of-risk/#messaging-protocol","text":"A cross-chain messaging protocol is responsible for communicating state transition events from applications on one network to applications on another. It should guarantee that these events are valid according to the canonical ledger state of the source network (safety) and ensure that all relevant state transitions are eventually communicated to their destination network (liveness). From the perspective of safety, an ideal message protocol construction would introduce no additional trust assumptions beyond what is assumed about the networks themselves. This would involve a destination network independently being able to verify that a) a state transition that resulted in a given message is valid according to the state transition rules of the source network and b) that the message has been finalized on the network as per the network consensus rules of the source.","title":"Messaging Protocol"},{"location":"framework/20categories/categories-of-risk/#full-client-verification-based-bridging","text":"A full-client verification bridge involves one network validating all state transitions and consensus rules of another network, in effect achieving both properties stated above. This type of bridging retains the strongest guarantees of the underlying networks and does not introduce any additional trust assumption. However, this approach introduces significant complexities in implementation and is hard to scale across diverse ecosystems. To date, these are employed only by layer 2 chains (optimistic and ZK rollups), and not across independent L1 networks.","title":"Full-client verification-based bridging"},{"location":"framework/20categories/categories-of-risk/#light-client-verification-based-bridging","text":"In a light-client verification bridge a destination network validates that a given block header (or state aggregate), from a source network, is valid only according to the consensus rules of a network, without executing and verifying individual state transitions. While light clients offer less security compared to full-client-based approaches, they too do not introduce additional trust assumptions, beyond those of the underlying networks. Different network protocols have different light-client protocols with differing levels of security assumptions and guarantees. The security guarantees of such bridges are subject to these limitations. We distinguish between two categories of light-client bridges: On-chain light-client protocol implementations: these involve implementing the light-client protocol as a smart contract on another. Typically block headers are relayed from the source network to the smart contract on a destination network for validation. An arbitrary state in a source network can then be proved against a validated block header stored by the smart contract on the destination network. Implementing, operating, and maintaining light-client-based bridges can be difficult, expensive, or infeasible, making this difficult to apply across diverse ecosystems. Validity Proof Bridges (aka ZK bridges)","title":"Light-client verification-based bridging"},{"location":"framework/20categories/categories-of-risk/#third-party-attestation-reliant-bridging","text":"While the above approaches offer better security guarantees because they remove the need for additional trust assumptions, they are difficult to implement and operate across diverse ecosystems. Hence, most cross-chain protocols introduce additional sources of trust in the form of third-party attestors. In general, such models rely on trusted third parties serving as oracles that attest and relay state events occurring in a source network, to a destination network. The security models of such bridges rely on the honest behavior of such attestors, either because they are game theoretically incentivized or have their reputation at stake. We generally distinguish between three categories of such bridges, based on the security model they employ. Proof-of-Authority approaches: rely on well-known legal entities running nodes that attest to the validity of messages from one network to another. Such bridges assume that a) parties are strongly incentivized to maintain their reputation and would thus not misbehave and b) that in the event of misbehavior legal recourse could be pursued against such entities. Considerations: How many such entities are employed by the network? What are the specific honesty threshold assumptions for guaranteeing safety and liveness? What are the specific characteristics of the cryptographic schemes employed? How reputable are such entities? What is the true cost of reputational damage for such entities? What is the market cap of such entities? Do such entities have competing interests with users of this bridge? e.g. Trading firms that might benefit from cross-domain MEV? How do the above disincentives to misbehavior compare against the TVL or total volume transacted by layers atop the messaging bridge? In what jurisdictions are the entities domiciled? Can these entities be coerced by regulations to censor transactions? Proof-of-Stake approaches: rely on a set of parties having a financial stake in honestly relaying valid state information from one network to another. Considerations: How many such entities are employed by the network? What are the specific honesty threshold assumptions for guaranteeing safety and liveness? What are the specific characteristics of the cryptographic schemes employed? How is the stake distributed across networks? (i.e. concentrated amongst few parties vs diffuse across many parties) What exactly is staked by validators? Is it a bridge-specific token? What are the dynamics that drive the value of such tokens? What is the cost of bribing or corrupting a threshold of such validators to violate safety or liveness? How does the bridge adapt to active misbehavior by a portion of the validators? Optimistic approaches - honest minority (but incentive alignment that such a minority exists) A number of protocols employ a hybrid approach, that utilizes different approaches for different legs of the cross-chain interaction.","title":"Third-party attestation reliant bridging"},{"location":"framework/20categories/categories-of-risk/#coordination-protocols","text":"Atomicity e.g. GPACT","title":"Coordination Protocols"},{"location":"framework/20categories/categories-of-risk/#token-bridges","text":"Token bridges are protocols that enable the transfer of assets from one network to another. This can be enacted using either a lock-and-mint or a burn-and-mint mechanism. In both cases, the protocol involves minting synthetic assets on a destination that are claimable for a corresponding amount of underlying assets at a later time. The invariant such protocols must preserve is that the value of an asset only resides in one place at a given time and that the total supply of synthetic assets matches the total underlying. Scenarios in which either locked assets on a source network are stolen or synthetic assets are arbitrarily minted on a destination network, break these invariants. This creates a perpetual risk for token holders of synthetic assets, in which these assets could become worthless in the event of such failures. Moreover, lock-and-mint token bridges in particular create honey pots that make them an ideal target for malicious actors. A significant portion of bridge hacks over the last couple of years has involved this source of risk.","title":"Token Bridges"},{"location":"framework/20categories/categories-of-risk/#liquidity-networks","text":"Note: include HTLCs as a possible design approach","title":"Liquidity Networks"},{"location":"framework/20categories/categories-of-risk/#protocol-implementation-risk","text":"The design of contracts and code implementation changes the risk profile of the project. This section discusses design features and then works through software development implementation risks.","title":"Protocol Implementation Risk"},{"location":"framework/20categories/categories-of-risk/#mixing-of-control-and-data-plane","text":"The terms Control Plane and Data Plane come from networking [ Wikipedia ]. In the context of networking, the Control Plane configures the network topology and routing tables, and the Data Plane is the information that is communicated across the network. In the context of computing, the Control Plane is the configuration of the system, and the Data Plane is the data processing. Functions in smart contracts can be ones that control the configuration of the contract. These can be thought of as Control Plane functions. For example, a function to pause the contract is a Control Plane function. Data Plane functions are functions that process data. For example, a function to mint some tokens is a Data Plane function. Poor project design can result in smart contract functions that contain both Control Plane and Data Plane logic. Mixing these two planes in the one function dramatically increases the risk of the project. An attacker may be able to compromise the Data Plane part of a mixed processing function, and then use that to change the configuration of the project, accessing the Control Plane part of the mixed function. This can lead to the attacker having the ability to control aspects of the project such as minting tokens.","title":"Mixing of Control and Data Plane"},{"location":"framework/20categories/categories-of-risk/#example","text":"As example of this type of issue being exploited is the August 2021 PolyNetwork issue . The PolyNetwork code was written such that its EthCrossChainManager contract was the owner of the EthCrossChainData contract. The EthCrossChainData contract held important information including the public keys used to verify crosschain requests. Doing this allows for function calls for EthCrossChainData to go via the EthCrossChainManager contract. Access from the EthCrossChainManager contract to the EthCrossChainData contract could be deemed part of the Control Plane. The EthCrossChainManager contract also had a function verifyHeaderAndExecuteTx that was used to process Data Plane requests. The attacker was able to create a carefully constructed call to verifyHeaderAndExecuteTx that allowed the Data Plane request to modify data in the EthCrossChainData , that ultimately led to the attacker being able to steal funds. The PolyNetwork code would not have been vulnerable to this type of attack if there had been a clear separation of Control Plane and Data Plane. For example, rather than doing updates to the EthCrossChainData contract via the EthCrossChainManager contract, updates could have been only allowed from an Externally Owned Account (EOA) or a MultiSig Wallet account.","title":"Example"},{"location":"framework/20categories/categories-of-risk/#ability-to-pause-project","text":"All Data Plane functions should be pausable . For example, a bridge contract could have a function that could transfer coins based on actions on another blockchain. The ability to pause a function in a project allows administrators to stop functions from successfully executing. If there is a vulnerability that is being actively exploited in a project, having the ability to pause a function could stop the exploitation of the project midway through the attack. For Ethereum based projects, the OpenZeppelin project has an example contract Pausable.sol that can be used to implement pausing. Using this template, pausing a function becomes as simple as adding a modifier whenNotPaused . The code below shows how this would work in practice. contract Example is Pausable { function pause() external onlyOwner { _pause(); } function transfer( address _sender, address _tokenContract, address _recipient, uint256 _amount ) external whenNotPaused { // Only executed when not paused When analyzing whether a project can be paused, it is important to check whether all data processing functions can be paused, or just some parts of the project.","title":"Ability to Pause Project"},{"location":"framework/20categories/categories-of-risk/#example_1","text":"For example, in August 2022 the Nomad Bridge had an issue (see Rekt for an analysis of the issue from people outside the team). An attacker was able to determine a methodology for stealing funds using the Replica contract's process() function. Depite most of the Data Plane processing functions in the project being pausable, the process() function was not. This meant that the attack was able to proceed without the administrators of the project being able to stop it.","title":"Example"},{"location":"framework/20categories/categories-of-risk/#role-based-access-control","text":"Role Based Access Control (RBAC) allows different entites to be responsible for different configuration actions. Systems that are managed by a single entity are inherently less secure than those with narrowly-scoped privileges for different entities and specific contexts. With contracts, this can be used to limit which accounts can execute which functions. For example, imagine a contract that operates as a crosschain bridge. It could have a role called PAUSER . This role could be required to call a function that enables pausing of the contract. Any transaction submitted by an account that did not have the PAUSER role would be reverted. Simplistic contracts might have a single role, OWNER , that can only be assigned to one account. For these contracts, the owner account is the only account that can submit transactions that call configuration functions without reverting. The greater degree of flexibility afforded by Role Based Access Control compared to simplistic OWNER style access control has security implications. For example, a contract might be able to mint new tokens, and thus have a MINTER role to control this action. Minting new tokens could change the tokenomics of the contract, and hence must only be executed if there is agreement between administrators. Access to this configuration action might be limited to a multi-signature wallet account. The same contract might have a PAUSER role that can be used to stop data processing within the contract. The action to pause the contract needs to occur as quickly as possible, to halt an in-progress attack. However, access to the role needs to be limited to trusted accounts, to prevent attackers causing a Denial of Service attack on the contract, by continually pausing the contract. Using a multi-signature wallet to control this action is not ideal, as multiple parties would need to work together to pause the contract, thus allowing attacks to continue longer than they otherwise would. In this situation, multiple trusted accounts could be granted PAUSER role. Any one of the accounts could then pause the contract. For a small project, when a contract is deployed, it might be tempting to use simplistic OWNER style access control. However, it is better to deploy a contract configured for fine grain Role Based Access Control, where all roles are initially assigned to the one account. In this way, as the project using the contract matures, new accounts can be granted roles and the original account's access can be revoked. It should be noted that the benefits of RBAC are only realised once access for different roles is allocated to additional accounts. For Ethereum based projects, the OpenZeppelin project has an example contract AccessControl.sol that can be used to implement Role Based Access Control. Using this template, checking an address has been granted a role becomes as simple as calling the function hasRole . The code below shows how this would work in practice. contract Example is Pausable, AccessControl { constructor() { _setupRole(DEFAULT_ADMIN_ROLE, msg.sender); _setupRole(PAUSER_ROLE, msg.sender); } function pause() external { require(hasRole(PAUSER_ROLE, msg.sender), \"Must have PAUSER role\"); _pause(); } }","title":"Role Based Access Control"},{"location":"framework/20categories/categories-of-risk/#upgradable","text":"TODO: This needs some thought. Upgrading can lead to rug-pulling, possibly by attackers who gain access to the address with upgrade privileges. However, code often has bugs. Additionally, new features can be added. Hence, the ability to upgrade is important. Are different upgrade mechanisms more and less risky? Transparent proxy Poor implementation where storage slots are mistakenly re-used has led to vulnerabilities. Deploy new contract and point front end at new contract. Non-transparent proxy with separate data contract.","title":"Upgradable"},{"location":"framework/20categories/categories-of-risk/#ability-to-ban-addresses","text":"Addresses may be associated with stolen funds. Tornado Cash was a project that had sanctions placed against it due to its association with stolen funds. Projects that have the ability to block these addresses, or freeze in-transit funds are more likely to avoid this type of regulatory risk.","title":"Ability to Ban Addresses"},{"location":"framework/20categories/categories-of-risk/#well-known-platform","text":"More people are likely to be able to review and understand projects that are created in environments that they are familiar with. The majority of the blockchain developers in the world understand Ethereum and the Ethereum Virtual Machine (EVM). Hence, projects that use blockchains that support the EVM, or that are forks or Ethereum, are inherently less risky than projects that involve other blockchains.","title":"Well Known Platform"},{"location":"framework/20categories/categories-of-risk/#well-known-smart-contract-programming-language","text":"More people are likely to be able to review and understand code that has been created in programming languages that they are familiar with. Solidity is the smart contract programming language known by most blockchain developers. Hence, projects that use Solidity are inherently less risky than projects that use other smart contract programming languages. Solidity Assembler can be used to implement complex features not available in standard Solidity. Assembler code is more complex than Solidity code and is more likely to contain bugs and have unexpected consequences.","title":"Well Known Smart Contract Programming Language"},{"location":"framework/20categories/categories-of-risk/#open-source-code","text":"If the code is stored in a public Github repository, it allows people to review the code and the test system. If many people view the code, then it is likely that defects in the code will be found. Additionally, it allows for the assessment of such things as the number of tests. Some people argue that a private Github repository is more secure, believing that issues can be hidden from attackers. However, attackers who are sufficiently motivated often obtain access of private repository or to a copy of the code, and are then able to exploit any vulnerabilities. Not having the repository public then hinders white hat developers from helping, in the case of an attack. When using a public repository, it is important that issues that relate to vulnerabilities and code fixes for vulnerabilities are not put on the public repository before a release including the vulnerability fix has been deployed. Not doing this equates to publishing vulnerabilities that can be used to exploit the project. The approach that should be taken is to review and test the vulnerability fix using the private repo, deploy from the private repo, and the push the fix to the public repo.","title":"Open Source Code"},{"location":"framework/20categories/categories-of-risk/#code-auditing","text":"TODO: This section needs to be re-worked. Has the code been audited? Have the deployed version audited? A source of risk is that a version of the code has been audited, but that the code deployed has not been audited.","title":"Code Auditing"},{"location":"framework/20categories/categories-of-risk/#verified-code-on-etherscan","text":"All deployed contracts should have the source code uploaded using the Etherscan verified code tool, or similar tools for other blockchains. Not being able to determine what code have been deployed reduces the trust stakeholders have in the project.","title":"Verified Code on Etherscan"},{"location":"framework/20categories/categories-of-risk/#testing","text":"Code that is not tested is far more likely to contain bugs than code that has been tested. Comprehensive tests allow new features to be added without fear of breaking existing functionality. Hence, the more comprehensive the testing of the project, the less risky the project is. TODO: discuss continuous integration","title":"Testing"},{"location":"framework/20categories/categories-of-risk/#formal-verification","text":"Formally verified code should prove that the code matches the specification. Hence, formal verification can not detect bugs in the design of the project. However, it will pick-up implementation bugs that testing might miss.","title":"Formal Verification"},{"location":"framework/20categories/categories-of-risk/#documentation","text":"More documentation makes a project easier to analyze. A lack of documentation can lead to confusion and issues being missed. Projects that have good documentation are easier to maintain. Types of documentation a good project should have are: Architecture document that includes the component and deployment architecture. Thread model that includes all parts of the project. Sequence diagrams for all major data flows. Test plan describing how the project will be tested. Smart contract code comments at the contract and function level. Off-chain code with comments at the class and method level. Test code with at least a class level comment.","title":"Documentation"},{"location":"framework/20categories/categories-of-risk/#secret-storage","text":"Most projects use cryptographic keys to operate the system. These keys could be stored in a network HSM or a hardware wallet, and not in a file on disk on a server.","title":"Secret Storage"},{"location":"framework/20categories/categories-of-risk/#product-development-maturity","text":"TODO: Software Development Lifecycle (SDLC)","title":"Product Development Maturity"},{"location":"framework/20categories/categories-of-risk/#protocol-operation-risk","text":"","title":"Protocol Operation Risk"},{"location":"framework/20categories/categories-of-risk/#operational-security","text":"TODO: Discuss security posture and how is applies.","title":"Operational Security"},{"location":"framework/20categories/categories-of-risk/#ability-to-pause","text":"If pausing is controlled by a multi-sig, then there is the risk that not enough parties can be gathered quickly enough to pause the project.","title":"Ability to Pause"},{"location":"framework/20categories/categories-of-risk/#codebase-diversity","text":"Is there just one implementation, or have multiple parties implemented the protocol?","title":"Codebase Diversity"},{"location":"framework/20categories/categories-of-risk/#decentralization-of-operations","text":"Is there a single operator of off-chain components, or are many parties involved?","title":"Decentralization of Operations"},{"location":"framework/20categories/categories-of-risk/#security-of-off-chain-systems","text":"TODO (e.g. validators) Standard security practices such as ISO27001","title":"Security of off-chain systems"},{"location":"framework/20categories/categories-of-risk/#vulnerability-response-plan","text":"Is there a vulnerability response plan? Is there a methodology for deploying an upgrade prior to committing code to a public github repo?","title":"Vulnerability Response Plan"},{"location":"framework/20categories/10network/network/","text":"Network Consensus Risk Cross-chain protocols enable the coordination of state changes across networks. This typically requires sending state information from a source network to one or more destination networks and performing consequent state changes. A fundamental assumption in this process is that: a) states in the source network are valid and final according to its consensus rules, and b) the underlying network can process all transactions in a timely manner. From the perspective of risk in cross-chain protocols, there are at least three considerations relating to these assumptions: 1. Protocols should only communicate states that have been finalized in the source network 1. Protocol security should be resilient to network liveness failures 1. Protocols should mitigate the impact of network safety violations Transaction Finality A transaction that is irrevocably included in a ledger is considered final . How finality is achieved varies across networks and can either be probabilistic or deterministic . Networks with deterministic finality offer absolute assurance about the state of a network after some time. In contrast, probabilistic models offer only degrees of confidence, with increasing assurance attained over time. For deterministic models, finality could be instantly achieved after a single block or eventually after several blocks. Networks with slower finality times increase latency in cross-chain communication, which impacts the customer experience. However, cross-chain protocols must ensure that the finality of a given state is achieved before relaying the state across chains. Cross-chain protocols, which optimize for performance and relay information across chains without sufficiently waiting for finality, risk creating inconsistencies across networks and the possible loss of a party's funds. Network Liveness Failures Some cross-chain protocols rely considerably on the underlying networks processing transactions within a given period. For instance, protocols might assume that cross-chain messages or fraud proofs can be submitted within a time window. However, some consensus protocols explicitly trade-off liveness for safety under certain conditions. That is, a network can halt for extended periods in the event that a portion of its validators are offline or unreachable. Cross-chain protocols must carefully account for these scenarios in their design. Network Safety Violations A fundamental and systematic problem for cross-chain protocols across sovereign networks is if the ledger of the underlying network undergoes significant reorganizations and reversions. This could result from active network attacks (e.g., 51% attack), hard forks, or bugs in protocol implementations. The likelihood of such failures is higher in chains with fewer validators, lower economic security, or new consensus protocols. Such risks are often beyond the control boundary of cross-chain infrastructure and affect all cross-chain protocols connected to a network simultaneously. For cross-chain protocols spanning independent networks, this likely represents a fundamental security limitation to the security guarantees that such protocols can offer. However, cross-chain protocols can reduce the impact of such failure by limiting contagion to other chains. If a consensus failure in one network can cascade to affect all other chains, then the security of a bridge is dependent on its weakest link. Additionally, cross-chain protocol builders should conduct adequate due diligence on the security and decentralisation properties of the networks they integrate.","title":"Network"},{"location":"framework/20categories/10network/network/#network-consensus-risk","text":"Cross-chain protocols enable the coordination of state changes across networks. This typically requires sending state information from a source network to one or more destination networks and performing consequent state changes. A fundamental assumption in this process is that: a) states in the source network are valid and final according to its consensus rules, and b) the underlying network can process all transactions in a timely manner. From the perspective of risk in cross-chain protocols, there are at least three considerations relating to these assumptions: 1. Protocols should only communicate states that have been finalized in the source network 1. Protocol security should be resilient to network liveness failures 1. Protocols should mitigate the impact of network safety violations","title":"Network Consensus Risk"},{"location":"framework/20categories/10network/network/#transaction-finality","text":"A transaction that is irrevocably included in a ledger is considered final . How finality is achieved varies across networks and can either be probabilistic or deterministic . Networks with deterministic finality offer absolute assurance about the state of a network after some time. In contrast, probabilistic models offer only degrees of confidence, with increasing assurance attained over time. For deterministic models, finality could be instantly achieved after a single block or eventually after several blocks. Networks with slower finality times increase latency in cross-chain communication, which impacts the customer experience. However, cross-chain protocols must ensure that the finality of a given state is achieved before relaying the state across chains. Cross-chain protocols, which optimize for performance and relay information across chains without sufficiently waiting for finality, risk creating inconsistencies across networks and the possible loss of a party's funds.","title":"Transaction Finality"},{"location":"framework/20categories/10network/network/#network-liveness-failures","text":"Some cross-chain protocols rely considerably on the underlying networks processing transactions within a given period. For instance, protocols might assume that cross-chain messages or fraud proofs can be submitted within a time window. However, some consensus protocols explicitly trade-off liveness for safety under certain conditions. That is, a network can halt for extended periods in the event that a portion of its validators are offline or unreachable. Cross-chain protocols must carefully account for these scenarios in their design.","title":"Network Liveness Failures"},{"location":"framework/20categories/10network/network/#network-safety-violations","text":"A fundamental and systematic problem for cross-chain protocols across sovereign networks is if the ledger of the underlying network undergoes significant reorganizations and reversions. This could result from active network attacks (e.g., 51% attack), hard forks, or bugs in protocol implementations. The likelihood of such failures is higher in chains with fewer validators, lower economic security, or new consensus protocols. Such risks are often beyond the control boundary of cross-chain infrastructure and affect all cross-chain protocols connected to a network simultaneously. For cross-chain protocols spanning independent networks, this likely represents a fundamental security limitation to the security guarantees that such protocols can offer. However, cross-chain protocols can reduce the impact of such failure by limiting contagion to other chains. If a consensus failure in one network can cascade to affect all other chains, then the security of a bridge is dependent on its weakest link. Additionally, cross-chain protocol builders should conduct adequate due diligence on the security and decentralisation properties of the networks they integrate.","title":"Network Safety Violations"},{"location":"framework/20categories/20architecture/architecture/","text":"Protocol Architecture Risk Protocol architecture risks relate to the design of the cross-chain communications protocol. The major consideration is the communications protocol trust assumptions. However, other more detailed design considerations can impose important risks. Messaging Protocol A cross-chain messaging protocol is responsible for communicating state transition events from applications on one network to applications on another. It should guarantee that these events are valid according to the canonical ledger state of the source network (safety) and ensure that all relevant state transitions are eventually communicated to their destination network (liveness). From the perspective of safety, an ideal message protocol construction would introduce no additional trust assumptions beyond what is assumed about the networks themselves. This would involve a destination network independently being able to verify that a) a state transition that resulted in a given message is valid according to the state transition rules of the source network and b) that the message has been finalized on the network as per the network consensus rules of the source. Full-client verification-based bridging A full-client verification bridge involves one network validating all state transitions and consensus rules of another network, in effect achieving both properties stated above. This type of bridging retains the strongest guarantees of the underlying networks and does not introduce any additional trust assumption. However, this approach introduces significant complexities in implementation and is hard to scale across diverse ecosystems. To date, these are employed only by layer 2 chains (optimistic and ZK rollups), and not across independent L1 networks. Light-client verification-based bridging In a light-client verification bridge a destination network validates that a given block header (or state aggregate), from a source network, is valid only according to the consensus rules of a network, without executing and verifying individual state transitions. While light clients offer less security compared to full-client-based approaches, they too do not introduce additional trust assumptions, beyond those of the underlying networks. Different network protocols have different light-client protocols with differing levels of security assumptions and guarantees. The security guarantees of such bridges are subject to these limitations. We distinguish between two categories of light-client bridges: On-chain light-client protocol implementations: these involve implementing the light-client protocol as a smart contract on another. Typically block headers are relayed from the source network to the smart contract on a destination network for validation. An arbitrary state in a source network can then be proved against a validated block header stored by the smart contract on the destination network. Implementing, operating, and maintaining light-client-based bridges can be difficult, expensive, or infeasible, making this difficult to apply across diverse ecosystems. Validity Proof Bridges (aka ZK bridges) Third-party attestation reliant bridging While the above approaches offer better security guarantees because they remove the need for additional trust assumptions, they are difficult to implement and operate across diverse ecosystems. Hence, most cross-chain protocols introduce additional sources of trust in the form of third-party attestors. In general, such models rely on trusted third parties serving as oracles that attest and relay state events occurring in a source network, to a destination network. The security models of such bridges rely on the honest behavior of such attestors, either because they are game theoretically incentivized or have their reputation at stake. We generally distinguish between three categories of such bridges, based on the security model they employ. Proof-of-Authority approaches: rely on well-known legal entities running nodes that attest to the validity of messages from one network to another. Such bridges assume that a) parties are strongly incentivized to maintain their reputation and would thus not misbehave and b) that in the event of misbehavior legal recourse could be pursued against such entities. Considerations: How many such entities are employed by the network? What are the specific honesty threshold assumptions for guaranteeing safety and liveness? What are the specific characteristics of the cryptographic schemes employed? How reputable are such entities? What is the true cost of reputational damage for such entities? What is the market cap of such entities? Do such entities have competing interests with users of this bridge? e.g. Trading firms that might benefit from cross-domain MEV? How do the above disincentives to misbehavior compare against the TVL or total volume transacted by layers atop the messaging bridge? In what jurisdictions are the entities domiciled? Can these entities be coerced by regulations to censor transactions? Proof-of-Stake approaches: rely on a set of parties having a financial stake in honestly relaying valid state information from one network to another. Considerations: How many such entities are employed by the network? What are the specific honesty threshold assumptions for guaranteeing safety and liveness? What are the specific characteristics of the cryptographic schemes employed? How is the stake distributed across networks? (i.e. concentrated amongst few parties vs diffuse across many parties) What exactly is staked by validators? Is it a bridge-specific token? What are the dynamics that drive the value of such tokens? What is the cost of bribing or corrupting a threshold of such validators to violate safety or liveness? How does the bridge adapt to active misbehavior by a portion of the validators? Optimistic approaches - honest minority (but incentive alignment that such a minority exists) A number of protocols employ a hybrid approach, that utilizes different approaches for different legs of the cross-chain interaction. Coordination Protocols Atomicity e.g. GPACT Token Bridges Token bridges are protocols that enable the transfer of assets from one network to another. This can be enacted using either a lock-and-mint or a burn-and-mint mechanism. In both cases, the protocol involves minting synthetic assets on a destination that are claimable for a corresponding amount of underlying assets at a later time. The invariant such protocols must preserve is that the value of an asset only resides in one place at a given time and that the total supply of synthetic assets matches the total underlying. Scenarios in which either locked assets on a source network are stolen or synthetic assets are arbitrarily minted on a destination network, break these invariants. This creates a perpetual risk for token holders of synthetic assets, in which these assets could become worthless in the event of such failures. Moreover, lock-and-mint token bridges in particular create honey pots that make them an ideal target for malicious actors. A significant portion of bridge hacks over the last couple of years has involved this source of risk. Liquidity Networks Note: include HTLCs as a possible design approach","title":"Architecture"},{"location":"framework/20categories/20architecture/architecture/#protocol-architecture-risk","text":"Protocol architecture risks relate to the design of the cross-chain communications protocol. The major consideration is the communications protocol trust assumptions. However, other more detailed design considerations can impose important risks.","title":"Protocol Architecture Risk"},{"location":"framework/20categories/20architecture/architecture/#messaging-protocol","text":"A cross-chain messaging protocol is responsible for communicating state transition events from applications on one network to applications on another. It should guarantee that these events are valid according to the canonical ledger state of the source network (safety) and ensure that all relevant state transitions are eventually communicated to their destination network (liveness). From the perspective of safety, an ideal message protocol construction would introduce no additional trust assumptions beyond what is assumed about the networks themselves. This would involve a destination network independently being able to verify that a) a state transition that resulted in a given message is valid according to the state transition rules of the source network and b) that the message has been finalized on the network as per the network consensus rules of the source.","title":"Messaging Protocol"},{"location":"framework/20categories/20architecture/architecture/#full-client-verification-based-bridging","text":"A full-client verification bridge involves one network validating all state transitions and consensus rules of another network, in effect achieving both properties stated above. This type of bridging retains the strongest guarantees of the underlying networks and does not introduce any additional trust assumption. However, this approach introduces significant complexities in implementation and is hard to scale across diverse ecosystems. To date, these are employed only by layer 2 chains (optimistic and ZK rollups), and not across independent L1 networks.","title":"Full-client verification-based bridging"},{"location":"framework/20categories/20architecture/architecture/#light-client-verification-based-bridging","text":"In a light-client verification bridge a destination network validates that a given block header (or state aggregate), from a source network, is valid only according to the consensus rules of a network, without executing and verifying individual state transitions. While light clients offer less security compared to full-client-based approaches, they too do not introduce additional trust assumptions, beyond those of the underlying networks. Different network protocols have different light-client protocols with differing levels of security assumptions and guarantees. The security guarantees of such bridges are subject to these limitations. We distinguish between two categories of light-client bridges: On-chain light-client protocol implementations: these involve implementing the light-client protocol as a smart contract on another. Typically block headers are relayed from the source network to the smart contract on a destination network for validation. An arbitrary state in a source network can then be proved against a validated block header stored by the smart contract on the destination network. Implementing, operating, and maintaining light-client-based bridges can be difficult, expensive, or infeasible, making this difficult to apply across diverse ecosystems. Validity Proof Bridges (aka ZK bridges)","title":"Light-client verification-based bridging"},{"location":"framework/20categories/20architecture/architecture/#third-party-attestation-reliant-bridging","text":"While the above approaches offer better security guarantees because they remove the need for additional trust assumptions, they are difficult to implement and operate across diverse ecosystems. Hence, most cross-chain protocols introduce additional sources of trust in the form of third-party attestors. In general, such models rely on trusted third parties serving as oracles that attest and relay state events occurring in a source network, to a destination network. The security models of such bridges rely on the honest behavior of such attestors, either because they are game theoretically incentivized or have their reputation at stake. We generally distinguish between three categories of such bridges, based on the security model they employ. Proof-of-Authority approaches: rely on well-known legal entities running nodes that attest to the validity of messages from one network to another. Such bridges assume that a) parties are strongly incentivized to maintain their reputation and would thus not misbehave and b) that in the event of misbehavior legal recourse could be pursued against such entities. Considerations: How many such entities are employed by the network? What are the specific honesty threshold assumptions for guaranteeing safety and liveness? What are the specific characteristics of the cryptographic schemes employed? How reputable are such entities? What is the true cost of reputational damage for such entities? What is the market cap of such entities? Do such entities have competing interests with users of this bridge? e.g. Trading firms that might benefit from cross-domain MEV? How do the above disincentives to misbehavior compare against the TVL or total volume transacted by layers atop the messaging bridge? In what jurisdictions are the entities domiciled? Can these entities be coerced by regulations to censor transactions? Proof-of-Stake approaches: rely on a set of parties having a financial stake in honestly relaying valid state information from one network to another. Considerations: How many such entities are employed by the network? What are the specific honesty threshold assumptions for guaranteeing safety and liveness? What are the specific characteristics of the cryptographic schemes employed? How is the stake distributed across networks? (i.e. concentrated amongst few parties vs diffuse across many parties) What exactly is staked by validators? Is it a bridge-specific token? What are the dynamics that drive the value of such tokens? What is the cost of bribing or corrupting a threshold of such validators to violate safety or liveness? How does the bridge adapt to active misbehavior by a portion of the validators? Optimistic approaches - honest minority (but incentive alignment that such a minority exists) A number of protocols employ a hybrid approach, that utilizes different approaches for different legs of the cross-chain interaction.","title":"Third-party attestation reliant bridging"},{"location":"framework/20categories/20architecture/architecture/#coordination-protocols","text":"Atomicity e.g. GPACT","title":"Coordination Protocols"},{"location":"framework/20categories/20architecture/architecture/#token-bridges","text":"Token bridges are protocols that enable the transfer of assets from one network to another. This can be enacted using either a lock-and-mint or a burn-and-mint mechanism. In both cases, the protocol involves minting synthetic assets on a destination that are claimable for a corresponding amount of underlying assets at a later time. The invariant such protocols must preserve is that the value of an asset only resides in one place at a given time and that the total supply of synthetic assets matches the total underlying. Scenarios in which either locked assets on a source network are stolen or synthetic assets are arbitrarily minted on a destination network, break these invariants. This creates a perpetual risk for token holders of synthetic assets, in which these assets could become worthless in the event of such failures. Moreover, lock-and-mint token bridges in particular create honey pots that make them an ideal target for malicious actors. A significant portion of bridge hacks over the last couple of years has involved this source of risk.","title":"Token Bridges"},{"location":"framework/20categories/20architecture/architecture/#liquidity-networks","text":"Note: include HTLCs as a possible design approach","title":"Liquidity Networks"},{"location":"framework/20categories/20architecture/bridge-aggregation-protocols/","text":"Bridge Aggregation Protocols TODO: Aggregation protocols add an extra layer of abstraction. This extra layer can introduce issues.","title":"Bridge aggregation protocols"},{"location":"framework/20categories/20architecture/bridge-aggregation-protocols/#bridge-aggregation-protocols","text":"TODO: Aggregation protocols add an extra layer of abstraction. This extra layer can introduce issues.","title":"Bridge Aggregation Protocols"},{"location":"framework/20categories/20architecture/coordination/","text":"Coordination Protocols Atomicity e.g. GPACT","title":"Coordination"},{"location":"framework/20categories/20architecture/coordination/#coordination-protocols","text":"Atomicity e.g. GPACT","title":"Coordination Protocols"},{"location":"framework/20categories/20architecture/liquidity-networks/","text":"Liquidity Networks Note: include HTLCs as a possible design approach","title":"Liquidity networks"},{"location":"framework/20categories/20architecture/liquidity-networks/#liquidity-networks","text":"Note: include HTLCs as a possible design approach","title":"Liquidity Networks"},{"location":"framework/20categories/20architecture/messaging/","text":"Messaging Protocol A cross-chain messaging protocol is responsible for communicating state transition events from applications on one network to applications on another. It should guarantee that these events are valid according to the canonical ledger state of the source network (safety) and ensure that all relevant state transitions are eventually communicated to their destination network (liveness). From the perspective of safety, an ideal message protocol construction would introduce no additional trust assumptions beyond what is assumed about the networks themselves. This would involve a destination network independently being able to verify that a) a state transition that resulted in a given message is valid according to the state transition rules of the source network and b) that the message has been finalized on the network as per the network consensus rules of the source. Full-client verification-based bridging A full-client verification bridge involves one network validating all state transitions and consensus rules of another network, in effect achieving both properties stated above. This type of bridging retains the strongest guarantees of the underlying networks and does not introduce any additional trust assumption. However, this approach introduces significant complexities in implementation and is hard to scale across diverse ecosystems. To date, these are employed only by layer 2 chains (optimistic and ZK rollups), and not across independent L1 networks. Light-client verification-based bridging In a light-client verification bridge a destination network validates that a given block header (or state aggregate), from a source network, is valid only according to the consensus rules of a network, without executing and verifying individual state transitions. While light clients offer less security compared to full-client-based approaches, they too do not introduce additional trust assumptions, beyond those of the underlying networks. Different network protocols have different light-client protocols with differing levels of security assumptions and guarantees. The security guarantees of such bridges are subject to these limitations. We distinguish between two categories of light-client bridges: On-chain light-client protocol implementations: these involve implementing the light-client protocol as a smart contract on another. Typically block headers are relayed from the source network to the smart contract on a destination network for validation. An arbitrary state in a source network can then be proved against a validated block header stored by the smart contract on the destination network. Implementing, operating, and maintaining light-client-based bridges can be difficult, expensive, or infeasible, making this difficult to apply across diverse ecosystems. Validity Proof Bridges (aka ZK bridges) Third-party attestation reliant bridging While the above approaches offer better security guarantees because they remove the need for additional trust assumptions, they are difficult to implement and operate across diverse ecosystems. Hence, most cross-chain protocols introduce additional sources of trust in the form of third-party attestors. In general, such models rely on trusted third parties serving as oracles that attest and relay state events occurring in a source network, to a destination network. The security models of such bridges rely on the honest behavior of such attestors, either because they are game theoretically incentivized or have their reputation at stake. We generally distinguish between three categories of such bridges, based on the security model they employ. Proof-of-Authority approaches: rely on well-known legal entities running nodes that attest to the validity of messages from one network to another. Such bridges assume that a) parties are strongly incentivized to maintain their reputation and would thus not misbehave and b) that in the event of misbehavior legal recourse could be pursued against such entities. Considerations: How many such entities are employed by the network? What are the specific honesty threshold assumptions for guaranteeing safety and liveness? What are the specific characteristics of the cryptographic schemes employed? How reputable are such entities? What is the true cost of reputational damage for such entities? What is the market cap of such entities? Do such entities have competing interests with users of this bridge? e.g. Trading firms that might benefit from cross-domain MEV? How do the above disincentives to misbehavior compare against the TVL or total volume transacted by layers atop the messaging bridge? In what jurisdictions are the entities domiciled? Can these entities be coerced by regulations to censor transactions? Proof-of-Stake approaches: rely on a set of parties having a financial stake in honestly relaying valid state information from one network to another. Considerations: How many such entities are employed by the network? What are the specific honesty threshold assumptions for guaranteeing safety and liveness? What are the specific characteristics of the cryptographic schemes employed? How is the stake distributed across networks? (i.e. concentrated amongst few parties vs diffuse across many parties) What exactly is staked by validators? Is it a bridge-specific token? What are the dynamics that drive the value of such tokens? What is the cost of bribing or corrupting a threshold of such validators to violate safety or liveness? How does the bridge adapt to active misbehavior by a portion of the validators? Optimistic approaches - honest minority (but incentive alignment that such a minority exists) A number of protocols employ a hybrid approach, that utilizes different approaches for different legs of the cross-chain interaction.","title":"Messaging"},{"location":"framework/20categories/20architecture/messaging/#messaging-protocol","text":"A cross-chain messaging protocol is responsible for communicating state transition events from applications on one network to applications on another. It should guarantee that these events are valid according to the canonical ledger state of the source network (safety) and ensure that all relevant state transitions are eventually communicated to their destination network (liveness). From the perspective of safety, an ideal message protocol construction would introduce no additional trust assumptions beyond what is assumed about the networks themselves. This would involve a destination network independently being able to verify that a) a state transition that resulted in a given message is valid according to the state transition rules of the source network and b) that the message has been finalized on the network as per the network consensus rules of the source.","title":"Messaging Protocol"},{"location":"framework/20categories/20architecture/messaging/#full-client-verification-based-bridging","text":"A full-client verification bridge involves one network validating all state transitions and consensus rules of another network, in effect achieving both properties stated above. This type of bridging retains the strongest guarantees of the underlying networks and does not introduce any additional trust assumption. However, this approach introduces significant complexities in implementation and is hard to scale across diverse ecosystems. To date, these are employed only by layer 2 chains (optimistic and ZK rollups), and not across independent L1 networks.","title":"Full-client verification-based bridging"},{"location":"framework/20categories/20architecture/messaging/#light-client-verification-based-bridging","text":"In a light-client verification bridge a destination network validates that a given block header (or state aggregate), from a source network, is valid only according to the consensus rules of a network, without executing and verifying individual state transitions. While light clients offer less security compared to full-client-based approaches, they too do not introduce additional trust assumptions, beyond those of the underlying networks. Different network protocols have different light-client protocols with differing levels of security assumptions and guarantees. The security guarantees of such bridges are subject to these limitations. We distinguish between two categories of light-client bridges: On-chain light-client protocol implementations: these involve implementing the light-client protocol as a smart contract on another. Typically block headers are relayed from the source network to the smart contract on a destination network for validation. An arbitrary state in a source network can then be proved against a validated block header stored by the smart contract on the destination network. Implementing, operating, and maintaining light-client-based bridges can be difficult, expensive, or infeasible, making this difficult to apply across diverse ecosystems. Validity Proof Bridges (aka ZK bridges)","title":"Light-client verification-based bridging"},{"location":"framework/20categories/20architecture/messaging/#third-party-attestation-reliant-bridging","text":"While the above approaches offer better security guarantees because they remove the need for additional trust assumptions, they are difficult to implement and operate across diverse ecosystems. Hence, most cross-chain protocols introduce additional sources of trust in the form of third-party attestors. In general, such models rely on trusted third parties serving as oracles that attest and relay state events occurring in a source network, to a destination network. The security models of such bridges rely on the honest behavior of such attestors, either because they are game theoretically incentivized or have their reputation at stake. We generally distinguish between three categories of such bridges, based on the security model they employ. Proof-of-Authority approaches: rely on well-known legal entities running nodes that attest to the validity of messages from one network to another. Such bridges assume that a) parties are strongly incentivized to maintain their reputation and would thus not misbehave and b) that in the event of misbehavior legal recourse could be pursued against such entities. Considerations: How many such entities are employed by the network? What are the specific honesty threshold assumptions for guaranteeing safety and liveness? What are the specific characteristics of the cryptographic schemes employed? How reputable are such entities? What is the true cost of reputational damage for such entities? What is the market cap of such entities? Do such entities have competing interests with users of this bridge? e.g. Trading firms that might benefit from cross-domain MEV? How do the above disincentives to misbehavior compare against the TVL or total volume transacted by layers atop the messaging bridge? In what jurisdictions are the entities domiciled? Can these entities be coerced by regulations to censor transactions? Proof-of-Stake approaches: rely on a set of parties having a financial stake in honestly relaying valid state information from one network to another. Considerations: How many such entities are employed by the network? What are the specific honesty threshold assumptions for guaranteeing safety and liveness? What are the specific characteristics of the cryptographic schemes employed? How is the stake distributed across networks? (i.e. concentrated amongst few parties vs diffuse across many parties) What exactly is staked by validators? Is it a bridge-specific token? What are the dynamics that drive the value of such tokens? What is the cost of bribing or corrupting a threshold of such validators to violate safety or liveness? How does the bridge adapt to active misbehavior by a portion of the validators? Optimistic approaches - honest minority (but incentive alignment that such a minority exists) A number of protocols employ a hybrid approach, that utilizes different approaches for different legs of the cross-chain interaction.","title":"Third-party attestation reliant bridging"},{"location":"framework/20categories/20architecture/token-bridges/","text":"Token Bridges Token bridges are protocols that enable the transfer of assets from one network to another. This can be enacted using either a lock-and-mint or a burn-and-mint mechanism. In both cases, the protocol involves minting synthetic assets on a destination that are claimable for a corresponding amount of underlying assets at a later time. The invariant such protocols must preserve is that the value of an asset only resides in one place at a given time and that the total supply of synthetic assets matches the total underlying. Scenarios in which either locked assets on a source network are stolen or synthetic assets are arbitrarily minted on a destination network, break these invariants. This creates a perpetual risk for token holders of synthetic assets, in which these assets could become worthless in the event of such failures. Moreover, lock-and-mint token bridges in particular create honey pots that make them an ideal target for malicious actors. A significant portion of bridge hacks over the last couple of years has involved this source of risk.","title":"Token bridges"},{"location":"framework/20categories/20architecture/token-bridges/#token-bridges","text":"Token bridges are protocols that enable the transfer of assets from one network to another. This can be enacted using either a lock-and-mint or a burn-and-mint mechanism. In both cases, the protocol involves minting synthetic assets on a destination that are claimable for a corresponding amount of underlying assets at a later time. The invariant such protocols must preserve is that the value of an asset only resides in one place at a given time and that the total supply of synthetic assets matches the total underlying. Scenarios in which either locked assets on a source network are stolen or synthetic assets are arbitrarily minted on a destination network, break these invariants. This creates a perpetual risk for token holders of synthetic assets, in which these assets could become worthless in the event of such failures. Moreover, lock-and-mint token bridges in particular create honey pots that make them an ideal target for malicious actors. A significant portion of bridge hacks over the last couple of years has involved this source of risk.","title":"Token Bridges"},{"location":"framework/20categories/30implementation/access-control/","text":"Role Based Access Control Role Based Access Control (RBAC) allows different entites to be responsible for different configuration actions. Systems that are managed by a single entity are inherently less secure than those with narrowly-scoped privileges for different entities and specific contexts. With contracts, this can be used to limit which accounts can execute which functions. For example, imagine a contract that operates as a crosschain bridge. It could have a role called PAUSER . This role could be required to call a function that enables pausing of the contract. Any transaction submitted by an account that did not have the PAUSER role would be reverted. Simplistic contracts might have a single role, OWNER , that can only be assigned to one account. For these contracts, the owner account is the only account that can submit transactions that call configuration functions without reverting. The greater degree of flexibility afforded by Role Based Access Control compared to simplistic OWNER style access control has security implications. For example, a contract might be able to mint new tokens, and thus have a MINTER role to control this action. Minting new tokens could change the tokenomics of the contract, and hence must only be executed if there is agreement between administrators. Access to this configuration action might be limited to a multi-signature wallet account. The same contract might have a PAUSER role that can be used to stop data processing within the contract. The action to pause the contract needs to occur as quickly as possible, to halt an in-progress attack. However, access to the role needs to be limited to trusted accounts, to prevent attackers causing a Denial of Service attack on the contract, by continually pausing the contract. Using a multi-signature wallet to control this action is not ideal, as multiple parties would need to work together to pause the contract, thus allowing attacks to continue longer than they otherwise would. In this situation, multiple trusted accounts could be granted PAUSER role. Any one of the accounts could then pause the contract. For a small project, when a contract is deployed, it might be tempting to use simplistic OWNER style access control. However, it is better to deploy a contract configured for fine grain Role Based Access Control, where all roles are initially assigned to the one account. In this way, as the project using the contract matures, new accounts can be granted roles and the original account's access can be revoked. It should be noted that the benefits of RBAC are only realised once access for different roles is allocated to additional accounts. For Ethereum based projects, the OpenZeppelin project has an example contract AccessControl.sol that can be used to implement Role Based Access Control. Using this template, checking an address has been granted a role becomes as simple as calling the function hasRole . The code below shows how this would work in practice. contract Example is Pausable, AccessControl { constructor() { _setupRole(DEFAULT_ADMIN_ROLE, msg.sender); _setupRole(PAUSER_ROLE, msg.sender); } function pause() external { require(hasRole(PAUSER_ROLE, msg.sender), \"Must have PAUSER role\"); _pause(); } }","title":"Access control"},{"location":"framework/20categories/30implementation/access-control/#role-based-access-control","text":"Role Based Access Control (RBAC) allows different entites to be responsible for different configuration actions. Systems that are managed by a single entity are inherently less secure than those with narrowly-scoped privileges for different entities and specific contexts. With contracts, this can be used to limit which accounts can execute which functions. For example, imagine a contract that operates as a crosschain bridge. It could have a role called PAUSER . This role could be required to call a function that enables pausing of the contract. Any transaction submitted by an account that did not have the PAUSER role would be reverted. Simplistic contracts might have a single role, OWNER , that can only be assigned to one account. For these contracts, the owner account is the only account that can submit transactions that call configuration functions without reverting. The greater degree of flexibility afforded by Role Based Access Control compared to simplistic OWNER style access control has security implications. For example, a contract might be able to mint new tokens, and thus have a MINTER role to control this action. Minting new tokens could change the tokenomics of the contract, and hence must only be executed if there is agreement between administrators. Access to this configuration action might be limited to a multi-signature wallet account. The same contract might have a PAUSER role that can be used to stop data processing within the contract. The action to pause the contract needs to occur as quickly as possible, to halt an in-progress attack. However, access to the role needs to be limited to trusted accounts, to prevent attackers causing a Denial of Service attack on the contract, by continually pausing the contract. Using a multi-signature wallet to control this action is not ideal, as multiple parties would need to work together to pause the contract, thus allowing attacks to continue longer than they otherwise would. In this situation, multiple trusted accounts could be granted PAUSER role. Any one of the accounts could then pause the contract. For a small project, when a contract is deployed, it might be tempting to use simplistic OWNER style access control. However, it is better to deploy a contract configured for fine grain Role Based Access Control, where all roles are initially assigned to the one account. In this way, as the project using the contract matures, new accounts can be granted roles and the original account's access can be revoked. It should be noted that the benefits of RBAC are only realised once access for different roles is allocated to additional accounts. For Ethereum based projects, the OpenZeppelin project has an example contract AccessControl.sol that can be used to implement Role Based Access Control. Using this template, checking an address has been granted a role becomes as simple as calling the function hasRole . The code below shows how this would work in practice. contract Example is Pausable, AccessControl { constructor() { _setupRole(DEFAULT_ADMIN_ROLE, msg.sender); _setupRole(PAUSER_ROLE, msg.sender); } function pause() external { require(hasRole(PAUSER_ROLE, msg.sender), \"Must have PAUSER role\"); _pause(); } }","title":"Role Based Access Control"},{"location":"framework/20categories/30implementation/audit/","text":"Code Auditing TODO: This section needs to be re-worked. Has the code been audited? Have the deployed version audited? A source of risk is that a version of the code has been audited, but that the code deployed has not been audited.","title":"Audit"},{"location":"framework/20categories/30implementation/audit/#code-auditing","text":"TODO: This section needs to be re-worked. Has the code been audited? Have the deployed version audited? A source of risk is that a version of the code has been audited, but that the code deployed has not been audited.","title":"Code Auditing"},{"location":"framework/20categories/30implementation/ban-address/","text":"Ability to Ban Addresses Addresses may be associated with stolen funds. Tornado Cash was a project that had sanctions placed against it due to its association with stolen funds. Projects that have the ability to block these addresses, or freeze in-transit funds are more likely to avoid this type of regulatory risk.","title":"Ban address"},{"location":"framework/20categories/30implementation/ban-address/#ability-to-ban-addresses","text":"Addresses may be associated with stolen funds. Tornado Cash was a project that had sanctions placed against it due to its association with stolen funds. Projects that have the ability to block these addresses, or freeze in-transit funds are more likely to avoid this type of regulatory risk.","title":"Ability to Ban Addresses"},{"location":"framework/20categories/30implementation/documentation/","text":"Documentation More documentation makes a project easier to analyze. A lack of documentation can lead to confusion and issues being missed. Projects that have good documentation are easier to maintain. Types of documentation a good project should have are: Architecture document that includes the component and deployment architecture. Thread model that includes all parts of the project. Sequence diagrams for all major data flows. Test plan describing how the project will be tested. Smart contract code comments at the contract and function level. Off-chain code with comments at the class and method level. Test code with at least a class level comment.","title":"Documentation"},{"location":"framework/20categories/30implementation/documentation/#documentation","text":"More documentation makes a project easier to analyze. A lack of documentation can lead to confusion and issues being missed. Projects that have good documentation are easier to maintain. Types of documentation a good project should have are: Architecture document that includes the component and deployment architecture. Thread model that includes all parts of the project. Sequence diagrams for all major data flows. Test plan describing how the project will be tested. Smart contract code comments at the contract and function level. Off-chain code with comments at the class and method level. Test code with at least a class level comment.","title":"Documentation"},{"location":"framework/20categories/30implementation/formal-verification/","text":"Formal Verification Formally verified code should prove that the code matches the specification. Hence, formal verification can not detect bugs in the design of the project. However, it will pick-up implementation bugs that testing might miss.","title":"Formal verification"},{"location":"framework/20categories/30implementation/formal-verification/#formal-verification","text":"Formally verified code should prove that the code matches the specification. Hence, formal verification can not detect bugs in the design of the project. However, it will pick-up implementation bugs that testing might miss.","title":"Formal Verification"},{"location":"framework/20categories/30implementation/known-language/","text":"Well Known Smart Contract Programming Language More people are likely to be able to review and understand code that has been created in programming languages that they are familiar with. Solidity is the smart contract programming language known by most blockchain developers. Hence, projects that use Solidity are inherently less risky than projects that use other smart contract programming languages. Solidity Assembler can be used to implement complex features not available in standard Solidity. Assembler code is more complex than Solidity code and is more likely to contain bugs and have unexpected consequences.","title":"Known language"},{"location":"framework/20categories/30implementation/known-language/#well-known-smart-contract-programming-language","text":"More people are likely to be able to review and understand code that has been created in programming languages that they are familiar with. Solidity is the smart contract programming language known by most blockchain developers. Hence, projects that use Solidity are inherently less risky than projects that use other smart contract programming languages. Solidity Assembler can be used to implement complex features not available in standard Solidity. Assembler code is more complex than Solidity code and is more likely to contain bugs and have unexpected consequences.","title":"Well Known Smart Contract Programming Language"},{"location":"framework/20categories/30implementation/known-platform/","text":"Well Known Platform More people are likely to be able to review and understand projects that are created in environments that they are familiar with. The majority of the blockchain developers in the world understand Ethereum and the Ethereum Virtual Machine (EVM). Hence, projects that use blockchains that support the EVM, or that are forks or Ethereum, are inherently less risky than projects that involve other blockchains.","title":"Known platform"},{"location":"framework/20categories/30implementation/known-platform/#well-known-platform","text":"More people are likely to be able to review and understand projects that are created in environments that they are familiar with. The majority of the blockchain developers in the world understand Ethereum and the Ethereum Virtual Machine (EVM). Hence, projects that use blockchains that support the EVM, or that are forks or Ethereum, are inherently less risky than projects that involve other blockchains.","title":"Well Known Platform"},{"location":"framework/20categories/30implementation/maturity/","text":"Product Development Maturity TODO: Software Development Lifecycle (SDLC)","title":"Maturity"},{"location":"framework/20categories/30implementation/maturity/#product-development-maturity","text":"TODO: Software Development Lifecycle (SDLC)","title":"Product Development Maturity"},{"location":"framework/20categories/30implementation/mixing-control-data-flow/","text":"Mixing of Control and Data Plane The terms Control Plane and Data Plane come from networking [ Wikipedia ]. In the context of networking, the Control Plane configures the network topology and routing tables, and the Data Plane is the information that is communicated across the network. In the context of computing, the Control Plane is the configuration of the system, and the Data Plane is the data processing. Functions in smart contracts can be ones that control the configuration of the contract. These can be thought of as Control Plane functions. For example, a function to pause the contract is a Control Plane function. Data Plane functions are functions that process data. For example, a function to mint some tokens is a Data Plane function. Poor project design can result in smart contract functions that contain both Control Plane and Data Plane logic. Mixing these two planes in the one function dramatically increases the risk of the project. An attacker may be able to compromise the Data Plane part of a mixed processing function, and then use that to change the configuration of the project, accessing the Control Plane part of the mixed function. This can lead to the attacker having the ability to control aspects of the project such as minting tokens. Example As example of this type of issue being exploited is the August 2021 PolyNetwork issue . The PolyNetwork code was written such that its EthCrossChainManager contract was the owner of the EthCrossChainData contract. The EthCrossChainData contract held important information including the public keys used to verify crosschain requests. Doing this allows for function calls for EthCrossChainData to go via the EthCrossChainManager contract. Access from the EthCrossChainManager contract to the EthCrossChainData contract could be deemed part of the Control Plane. The EthCrossChainManager contract also had a function verifyHeaderAndExecuteTx that was used to process Data Plane requests. The attacker was able to create a carefully constructed call to verifyHeaderAndExecuteTx that allowed the Data Plane request to modify data in the EthCrossChainData , that ultimately led to the attacker being able to steal funds. The PolyNetwork code would not have been vulnerable to this type of attack if there had been a clear separation of Control Plane and Data Plane. For example, rather than doing updates to the EthCrossChainData contract via the EthCrossChainManager contract, updates could have been only allowed from an Externally Owned Account (EOA) or a MultiSig Wallet account.","title":"Mixing control data flow"},{"location":"framework/20categories/30implementation/mixing-control-data-flow/#mixing-of-control-and-data-plane","text":"The terms Control Plane and Data Plane come from networking [ Wikipedia ]. In the context of networking, the Control Plane configures the network topology and routing tables, and the Data Plane is the information that is communicated across the network. In the context of computing, the Control Plane is the configuration of the system, and the Data Plane is the data processing. Functions in smart contracts can be ones that control the configuration of the contract. These can be thought of as Control Plane functions. For example, a function to pause the contract is a Control Plane function. Data Plane functions are functions that process data. For example, a function to mint some tokens is a Data Plane function. Poor project design can result in smart contract functions that contain both Control Plane and Data Plane logic. Mixing these two planes in the one function dramatically increases the risk of the project. An attacker may be able to compromise the Data Plane part of a mixed processing function, and then use that to change the configuration of the project, accessing the Control Plane part of the mixed function. This can lead to the attacker having the ability to control aspects of the project such as minting tokens.","title":"Mixing of Control and Data Plane"},{"location":"framework/20categories/30implementation/mixing-control-data-flow/#example","text":"As example of this type of issue being exploited is the August 2021 PolyNetwork issue . The PolyNetwork code was written such that its EthCrossChainManager contract was the owner of the EthCrossChainData contract. The EthCrossChainData contract held important information including the public keys used to verify crosschain requests. Doing this allows for function calls for EthCrossChainData to go via the EthCrossChainManager contract. Access from the EthCrossChainManager contract to the EthCrossChainData contract could be deemed part of the Control Plane. The EthCrossChainManager contract also had a function verifyHeaderAndExecuteTx that was used to process Data Plane requests. The attacker was able to create a carefully constructed call to verifyHeaderAndExecuteTx that allowed the Data Plane request to modify data in the EthCrossChainData , that ultimately led to the attacker being able to steal funds. The PolyNetwork code would not have been vulnerable to this type of attack if there had been a clear separation of Control Plane and Data Plane. For example, rather than doing updates to the EthCrossChainData contract via the EthCrossChainManager contract, updates could have been only allowed from an Externally Owned Account (EOA) or a MultiSig Wallet account.","title":"Example"},{"location":"framework/20categories/30implementation/open-source/","text":"Open Source Code If the code is stored in a public Github repository, it allows people to review the code and the test system. If many people view the code, then it is likely that defects in the code will be found. Additionally, it allows for the assessment of such things as the number of tests. Some people argue that a private Github repository is more secure, believing that issues can be hidden from attackers. However, attackers who are sufficiently motivated often obtain access of private repository or to a copy of the code, and are then able to exploit any vulnerabilities. Not having the repository public then hinders white hat developers from helping, in the case of an attack. When using a public repository, it is important that issues that relate to vulnerabilities and code fixes for vulnerabilities are not put on the public repository before a release including the vulnerability fix has been deployed. Not doing this equates to publishing vulnerabilities that can be used to exploit the project. The approach that should be taken is to review and test the vulnerability fix using the private repo, deploy from the private repo, and the push the fix to the public repo.","title":"Open source"},{"location":"framework/20categories/30implementation/open-source/#open-source-code","text":"If the code is stored in a public Github repository, it allows people to review the code and the test system. If many people view the code, then it is likely that defects in the code will be found. Additionally, it allows for the assessment of such things as the number of tests. Some people argue that a private Github repository is more secure, believing that issues can be hidden from attackers. However, attackers who are sufficiently motivated often obtain access of private repository or to a copy of the code, and are then able to exploit any vulnerabilities. Not having the repository public then hinders white hat developers from helping, in the case of an attack. When using a public repository, it is important that issues that relate to vulnerabilities and code fixes for vulnerabilities are not put on the public repository before a release including the vulnerability fix has been deployed. Not doing this equates to publishing vulnerabilities that can be used to exploit the project. The approach that should be taken is to review and test the vulnerability fix using the private repo, deploy from the private repo, and the push the fix to the public repo.","title":"Open Source Code"},{"location":"framework/20categories/30implementation/pause/","text":"Ability to Pause Project All Data Plane functions should be pausable . For example, a bridge contract could have a function that could transfer coins based on actions on another blockchain. The ability to pause a function in a project allows administrators to stop functions from successfully executing. If there is a vulnerability that is being actively exploited in a project, having the ability to pause a function could stop the exploitation of the project midway through the attack. For Ethereum based projects, the OpenZeppelin project has an example contract Pausable.sol that can be used to implement pausing. Using this template, pausing a function becomes as simple as adding a modifier whenNotPaused . The code below shows how this would work in practice. contract Example is Pausable { function pause() external onlyOwner { _pause(); } function transfer( address _sender, address _tokenContract, address _recipient, uint256 _amount ) external whenNotPaused { // Only executed when not paused When analyzing whether a project can be paused, it is important to check whether all data processing functions can be paused, or just some parts of the project. Example For example, in August 2022 the Nomad Bridge had an issue (see Rekt for an analysis of the issue from people outside the team). An attacker was able to determine a methodology for stealing funds using the Replica contract's process() function. Depite most of the Data Plane processing functions in the project being pausable, the process() function was not. This meant that the attack was able to proceed without the administrators of the project being able to stop it.","title":"Pause"},{"location":"framework/20categories/30implementation/pause/#ability-to-pause-project","text":"All Data Plane functions should be pausable . For example, a bridge contract could have a function that could transfer coins based on actions on another blockchain. The ability to pause a function in a project allows administrators to stop functions from successfully executing. If there is a vulnerability that is being actively exploited in a project, having the ability to pause a function could stop the exploitation of the project midway through the attack. For Ethereum based projects, the OpenZeppelin project has an example contract Pausable.sol that can be used to implement pausing. Using this template, pausing a function becomes as simple as adding a modifier whenNotPaused . The code below shows how this would work in practice. contract Example is Pausable { function pause() external onlyOwner { _pause(); } function transfer( address _sender, address _tokenContract, address _recipient, uint256 _amount ) external whenNotPaused { // Only executed when not paused When analyzing whether a project can be paused, it is important to check whether all data processing functions can be paused, or just some parts of the project.","title":"Ability to Pause Project"},{"location":"framework/20categories/30implementation/pause/#example","text":"For example, in August 2022 the Nomad Bridge had an issue (see Rekt for an analysis of the issue from people outside the team). An attacker was able to determine a methodology for stealing funds using the Replica contract's process() function. Depite most of the Data Plane processing functions in the project being pausable, the process() function was not. This meant that the attack was able to proceed without the administrators of the project being able to stop it.","title":"Example"},{"location":"framework/20categories/30implementation/protocol-implementation-risk/","text":"Protocol Implementation Risk The design of contracts and code implementation changes the risk profile of the project. This section discusses design features and then works through software development implementation risks. Mixing of Control and Data Plane The terms Control Plane and Data Plane come from networking [ Wikipedia ]. In the context of networking, the Control Plane configures the network topology and routing tables, and the Data Plane is the information that is communicated across the network. In the context of computing, the Control Plane is the configuration of the system, and the Data Plane is the data processing. Functions in smart contracts can be ones that control the configuration of the contract. These can be thought of as Control Plane functions. For example, a function to pause the contract is a Control Plane function. Data Plane functions are functions that process data. For example, a function to mint some tokens is a Data Plane function. Poor project design can result in smart contract functions that contain both Control Plane and Data Plane logic. Mixing these two planes in the one function dramatically increases the risk of the project. An attacker may be able to compromise the Data Plane part of a mixed processing function, and then use that to change the configuration of the project, accessing the Control Plane part of the mixed function. This can lead to the attacker having the ability to control aspects of the project such as minting tokens. Example As example of this type of issue being exploited is the August 2021 PolyNetwork issue . The PolyNetwork code was written such that its EthCrossChainManager contract was the owner of the EthCrossChainData contract. The EthCrossChainData contract held important information including the public keys used to verify crosschain requests. Doing this allows for function calls for EthCrossChainData to go via the EthCrossChainManager contract. Access from the EthCrossChainManager contract to the EthCrossChainData contract could be deemed part of the Control Plane. The EthCrossChainManager contract also had a function verifyHeaderAndExecuteTx that was used to process Data Plane requests. The attacker was able to create a carefully constructed call to verifyHeaderAndExecuteTx that allowed the Data Plane request to modify data in the EthCrossChainData , that ultimately led to the attacker being able to steal funds. The PolyNetwork code would not have been vulnerable to this type of attack if there had been a clear separation of Control Plane and Data Plane. For example, rather than doing updates to the EthCrossChainData contract via the EthCrossChainManager contract, updates could have been only allowed from an Externally Owned Account (EOA) or a MultiSig Wallet account. Ability to Pause Project All Data Plane functions should be pausable . For example, a bridge contract could have a function that could transfer coins based on actions on another blockchain. The ability to pause a function in a project allows administrators to stop functions from successfully executing. If there is a vulnerability that is being actively exploited in a project, having the ability to pause a function could stop the exploitation of the project midway through the attack. For Ethereum based projects, the OpenZeppelin project has an example contract Pausable.sol that can be used to implement pausing. Using this template, pausing a function becomes as simple as adding a modifier whenNotPaused . The code below shows how this would work in practice. contract Example is Pausable { function pause() external onlyOwner { _pause(); } function transfer( address _sender, address _tokenContract, address _recipient, uint256 _amount ) external whenNotPaused { // Only executed when not paused When analyzing whether a project can be paused, it is important to check whether all data processing functions can be paused, or just some parts of the project. Example For example, in August 2022 the Nomad Bridge had an issue (see Rekt for an analysis of the issue from people outside the team). An attacker was able to determine a methodology for stealing funds using the Replica contract's process() function. Depite most of the Data Plane processing functions in the project being pausable, the process() function was not. This meant that the attack was able to proceed without the administrators of the project being able to stop it. Role Based Access Control Role Based Access Control (RBAC) allows different entites to be responsible for different configuration actions. Systems that are managed by a single entity are inherently less secure than those with narrowly-scoped privileges for different entities and specific contexts. With contracts, this can be used to limit which accounts can execute which functions. For example, imagine a contract that operates as a crosschain bridge. It could have a role called PAUSER . This role could be required to call a function that enables pausing of the contract. Any transaction submitted by an account that did not have the PAUSER role would be reverted. Simplistic contracts might have a single role, OWNER , that can only be assigned to one account. For these contracts, the owner account is the only account that can submit transactions that call configuration functions without reverting. The greater degree of flexibility afforded by Role Based Access Control compared to simplistic OWNER style access control has security implications. For example, a contract might be able to mint new tokens, and thus have a MINTER role to control this action. Minting new tokens could change the tokenomics of the contract, and hence must only be executed if there is agreement between administrators. Access to this configuration action might be limited to a multi-signature wallet account. The same contract might have a PAUSER role that can be used to stop data processing within the contract. The action to pause the contract needs to occur as quickly as possible, to halt an in-progress attack. However, access to the role needs to be limited to trusted accounts, to prevent attackers causing a Denial of Service attack on the contract, by continually pausing the contract. Using a multi-signature wallet to control this action is not ideal, as multiple parties would need to work together to pause the contract, thus allowing attacks to continue longer than they otherwise would. In this situation, multiple trusted accounts could be granted PAUSER role. Any one of the accounts could then pause the contract. For a small project, when a contract is deployed, it might be tempting to use simplistic OWNER style access control. However, it is better to deploy a contract configured for fine grain Role Based Access Control, where all roles are initially assigned to the one account. In this way, as the project using the contract matures, new accounts can be granted roles and the original account's access can be revoked. It should be noted that the benefits of RBAC are only realised once access for different roles is allocated to additional accounts. For Ethereum based projects, the OpenZeppelin project has an example contract AccessControl.sol that can be used to implement Role Based Access Control. Using this template, checking an address has been granted a role becomes as simple as calling the function hasRole . The code below shows how this would work in practice. contract Example is Pausable, AccessControl { constructor() { _setupRole(DEFAULT_ADMIN_ROLE, msg.sender); _setupRole(PAUSER_ROLE, msg.sender); } function pause() external { require(hasRole(PAUSER_ROLE, msg.sender), \"Must have PAUSER role\"); _pause(); } } Upgradable TODO: This needs some thought. Upgrading can lead to rug-pulling, possibly by attackers who gain access to the address with upgrade privileges. However, code often has bugs. Additionally, new features can be added. Hence, the ability to upgrade is important. Are different upgrade mechanisms more and less risky? Transparent proxy Poor implementation where storage slots are mistakenly re-used has led to vulnerabilities. Deploy new contract and point front end at new contract. Non-transparent proxy with separate data contract. Ability to Ban Addresses Addresses may be associated with stolen funds. Tornado Cash was a project that had sanctions placed against it due to its association with stolen funds. Projects that have the ability to block these addresses, or freeze in-transit funds are more likely to avoid this type of regulatory risk. Well Known Platform More people are likely to be able to review and understand projects that are created in environments that they are familiar with. The majority of the blockchain developers in the world understand Ethereum and the Ethereum Virtual Machine (EVM). Hence, projects that use blockchains that support the EVM, or that are forks or Ethereum, are inherently less risky than projects that involve other blockchains. Well Known Smart Contract Programming Language More people are likely to be able to review and understand code that has been created in programming languages that they are familiar with. Solidity is the smart contract programming language known by most blockchain developers. Hence, projects that use Solidity are inherently less risky than projects that use other smart contract programming languages. Solidity Assembler can be used to implement complex features not available in standard Solidity. Assembler code is more complex than Solidity code and is more likely to contain bugs and have unexpected consequences. Open Source Code If the code is stored in a public Github repository, it allows people to review the code and the test system. If many people view the code, then it is likely that defects in the code will be found. Additionally, it allows for the assessment of such things as the number of tests. Some people argue that a private Github repository is more secure, believing that issues can be hidden from attackers. However, attackers who are sufficiently motivated often obtain access of private repository or to a copy of the code, and are then able to exploit any vulnerabilities. Not having the repository public then hinders white hat developers from helping, in the case of an attack. When using a public repository, it is important that issues that relate to vulnerabilities and code fixes for vulnerabilities are not put on the public repository before a release including the vulnerability fix has been deployed. Not doing this equates to publishing vulnerabilities that can be used to exploit the project. The approach that should be taken is to review and test the vulnerability fix using the private repo, deploy from the private repo, and the push the fix to the public repo. Code Auditing TODO: This section needs to be re-worked. Has the code been audited? Have the deployed version audited? A source of risk is that a version of the code has been audited, but that the code deployed has not been audited. Verified Code on Etherscan All deployed contracts should have the source code uploaded using the Etherscan verified code tool, or similar tools for other blockchains. Not being able to determine what code have been deployed reduces the trust stakeholders have in the project. Testing Code that is not tested is far more likely to contain bugs than code that has been tested. Comprehensive tests allow new features to be added without fear of breaking existing functionality. Hence, the more comprehensive the testing of the project, the less risky the project is. TODO: discuss continuous integration Formal Verification Formally verified code should prove that the code matches the specification. Hence, formal verification can not detect bugs in the design of the project. However, it will pick-up implementation bugs that testing might miss. Documentation More documentation makes a project easier to analyze. A lack of documentation can lead to confusion and issues being missed. Projects that have good documentation are easier to maintain. Types of documentation a good project should have are: Architecture document that includes the component and deployment architecture. Thread model that includes all parts of the project. Sequence diagrams for all major data flows. Test plan describing how the project will be tested. Smart contract code comments at the contract and function level. Off-chain code with comments at the class and method level. Test code with at least a class level comment. Secret Storage Most projects use cryptographic keys to operate the system. These keys could be stored in a network HSM or a hardware wallet, and not in a file on disk on a server. Product Development Maturity TODO: Software Development Lifecycle (SDLC)","title":"Protocol implementation risk"},{"location":"framework/20categories/30implementation/protocol-implementation-risk/#protocol-implementation-risk","text":"The design of contracts and code implementation changes the risk profile of the project. This section discusses design features and then works through software development implementation risks.","title":"Protocol Implementation Risk"},{"location":"framework/20categories/30implementation/protocol-implementation-risk/#mixing-of-control-and-data-plane","text":"The terms Control Plane and Data Plane come from networking [ Wikipedia ]. In the context of networking, the Control Plane configures the network topology and routing tables, and the Data Plane is the information that is communicated across the network. In the context of computing, the Control Plane is the configuration of the system, and the Data Plane is the data processing. Functions in smart contracts can be ones that control the configuration of the contract. These can be thought of as Control Plane functions. For example, a function to pause the contract is a Control Plane function. Data Plane functions are functions that process data. For example, a function to mint some tokens is a Data Plane function. Poor project design can result in smart contract functions that contain both Control Plane and Data Plane logic. Mixing these two planes in the one function dramatically increases the risk of the project. An attacker may be able to compromise the Data Plane part of a mixed processing function, and then use that to change the configuration of the project, accessing the Control Plane part of the mixed function. This can lead to the attacker having the ability to control aspects of the project such as minting tokens.","title":"Mixing of Control and Data Plane"},{"location":"framework/20categories/30implementation/protocol-implementation-risk/#example","text":"As example of this type of issue being exploited is the August 2021 PolyNetwork issue . The PolyNetwork code was written such that its EthCrossChainManager contract was the owner of the EthCrossChainData contract. The EthCrossChainData contract held important information including the public keys used to verify crosschain requests. Doing this allows for function calls for EthCrossChainData to go via the EthCrossChainManager contract. Access from the EthCrossChainManager contract to the EthCrossChainData contract could be deemed part of the Control Plane. The EthCrossChainManager contract also had a function verifyHeaderAndExecuteTx that was used to process Data Plane requests. The attacker was able to create a carefully constructed call to verifyHeaderAndExecuteTx that allowed the Data Plane request to modify data in the EthCrossChainData , that ultimately led to the attacker being able to steal funds. The PolyNetwork code would not have been vulnerable to this type of attack if there had been a clear separation of Control Plane and Data Plane. For example, rather than doing updates to the EthCrossChainData contract via the EthCrossChainManager contract, updates could have been only allowed from an Externally Owned Account (EOA) or a MultiSig Wallet account.","title":"Example"},{"location":"framework/20categories/30implementation/protocol-implementation-risk/#ability-to-pause-project","text":"All Data Plane functions should be pausable . For example, a bridge contract could have a function that could transfer coins based on actions on another blockchain. The ability to pause a function in a project allows administrators to stop functions from successfully executing. If there is a vulnerability that is being actively exploited in a project, having the ability to pause a function could stop the exploitation of the project midway through the attack. For Ethereum based projects, the OpenZeppelin project has an example contract Pausable.sol that can be used to implement pausing. Using this template, pausing a function becomes as simple as adding a modifier whenNotPaused . The code below shows how this would work in practice. contract Example is Pausable { function pause() external onlyOwner { _pause(); } function transfer( address _sender, address _tokenContract, address _recipient, uint256 _amount ) external whenNotPaused { // Only executed when not paused When analyzing whether a project can be paused, it is important to check whether all data processing functions can be paused, or just some parts of the project.","title":"Ability to Pause Project"},{"location":"framework/20categories/30implementation/protocol-implementation-risk/#example_1","text":"For example, in August 2022 the Nomad Bridge had an issue (see Rekt for an analysis of the issue from people outside the team). An attacker was able to determine a methodology for stealing funds using the Replica contract's process() function. Depite most of the Data Plane processing functions in the project being pausable, the process() function was not. This meant that the attack was able to proceed without the administrators of the project being able to stop it.","title":"Example"},{"location":"framework/20categories/30implementation/protocol-implementation-risk/#role-based-access-control","text":"Role Based Access Control (RBAC) allows different entites to be responsible for different configuration actions. Systems that are managed by a single entity are inherently less secure than those with narrowly-scoped privileges for different entities and specific contexts. With contracts, this can be used to limit which accounts can execute which functions. For example, imagine a contract that operates as a crosschain bridge. It could have a role called PAUSER . This role could be required to call a function that enables pausing of the contract. Any transaction submitted by an account that did not have the PAUSER role would be reverted. Simplistic contracts might have a single role, OWNER , that can only be assigned to one account. For these contracts, the owner account is the only account that can submit transactions that call configuration functions without reverting. The greater degree of flexibility afforded by Role Based Access Control compared to simplistic OWNER style access control has security implications. For example, a contract might be able to mint new tokens, and thus have a MINTER role to control this action. Minting new tokens could change the tokenomics of the contract, and hence must only be executed if there is agreement between administrators. Access to this configuration action might be limited to a multi-signature wallet account. The same contract might have a PAUSER role that can be used to stop data processing within the contract. The action to pause the contract needs to occur as quickly as possible, to halt an in-progress attack. However, access to the role needs to be limited to trusted accounts, to prevent attackers causing a Denial of Service attack on the contract, by continually pausing the contract. Using a multi-signature wallet to control this action is not ideal, as multiple parties would need to work together to pause the contract, thus allowing attacks to continue longer than they otherwise would. In this situation, multiple trusted accounts could be granted PAUSER role. Any one of the accounts could then pause the contract. For a small project, when a contract is deployed, it might be tempting to use simplistic OWNER style access control. However, it is better to deploy a contract configured for fine grain Role Based Access Control, where all roles are initially assigned to the one account. In this way, as the project using the contract matures, new accounts can be granted roles and the original account's access can be revoked. It should be noted that the benefits of RBAC are only realised once access for different roles is allocated to additional accounts. For Ethereum based projects, the OpenZeppelin project has an example contract AccessControl.sol that can be used to implement Role Based Access Control. Using this template, checking an address has been granted a role becomes as simple as calling the function hasRole . The code below shows how this would work in practice. contract Example is Pausable, AccessControl { constructor() { _setupRole(DEFAULT_ADMIN_ROLE, msg.sender); _setupRole(PAUSER_ROLE, msg.sender); } function pause() external { require(hasRole(PAUSER_ROLE, msg.sender), \"Must have PAUSER role\"); _pause(); } }","title":"Role Based Access Control"},{"location":"framework/20categories/30implementation/protocol-implementation-risk/#upgradable","text":"TODO: This needs some thought. Upgrading can lead to rug-pulling, possibly by attackers who gain access to the address with upgrade privileges. However, code often has bugs. Additionally, new features can be added. Hence, the ability to upgrade is important. Are different upgrade mechanisms more and less risky? Transparent proxy Poor implementation where storage slots are mistakenly re-used has led to vulnerabilities. Deploy new contract and point front end at new contract. Non-transparent proxy with separate data contract.","title":"Upgradable"},{"location":"framework/20categories/30implementation/protocol-implementation-risk/#ability-to-ban-addresses","text":"Addresses may be associated with stolen funds. Tornado Cash was a project that had sanctions placed against it due to its association with stolen funds. Projects that have the ability to block these addresses, or freeze in-transit funds are more likely to avoid this type of regulatory risk.","title":"Ability to Ban Addresses"},{"location":"framework/20categories/30implementation/protocol-implementation-risk/#well-known-platform","text":"More people are likely to be able to review and understand projects that are created in environments that they are familiar with. The majority of the blockchain developers in the world understand Ethereum and the Ethereum Virtual Machine (EVM). Hence, projects that use blockchains that support the EVM, or that are forks or Ethereum, are inherently less risky than projects that involve other blockchains.","title":"Well Known Platform"},{"location":"framework/20categories/30implementation/protocol-implementation-risk/#well-known-smart-contract-programming-language","text":"More people are likely to be able to review and understand code that has been created in programming languages that they are familiar with. Solidity is the smart contract programming language known by most blockchain developers. Hence, projects that use Solidity are inherently less risky than projects that use other smart contract programming languages. Solidity Assembler can be used to implement complex features not available in standard Solidity. Assembler code is more complex than Solidity code and is more likely to contain bugs and have unexpected consequences.","title":"Well Known Smart Contract Programming Language"},{"location":"framework/20categories/30implementation/protocol-implementation-risk/#open-source-code","text":"If the code is stored in a public Github repository, it allows people to review the code and the test system. If many people view the code, then it is likely that defects in the code will be found. Additionally, it allows for the assessment of such things as the number of tests. Some people argue that a private Github repository is more secure, believing that issues can be hidden from attackers. However, attackers who are sufficiently motivated often obtain access of private repository or to a copy of the code, and are then able to exploit any vulnerabilities. Not having the repository public then hinders white hat developers from helping, in the case of an attack. When using a public repository, it is important that issues that relate to vulnerabilities and code fixes for vulnerabilities are not put on the public repository before a release including the vulnerability fix has been deployed. Not doing this equates to publishing vulnerabilities that can be used to exploit the project. The approach that should be taken is to review and test the vulnerability fix using the private repo, deploy from the private repo, and the push the fix to the public repo.","title":"Open Source Code"},{"location":"framework/20categories/30implementation/protocol-implementation-risk/#code-auditing","text":"TODO: This section needs to be re-worked. Has the code been audited? Have the deployed version audited? A source of risk is that a version of the code has been audited, but that the code deployed has not been audited.","title":"Code Auditing"},{"location":"framework/20categories/30implementation/protocol-implementation-risk/#verified-code-on-etherscan","text":"All deployed contracts should have the source code uploaded using the Etherscan verified code tool, or similar tools for other blockchains. Not being able to determine what code have been deployed reduces the trust stakeholders have in the project.","title":"Verified Code on Etherscan"},{"location":"framework/20categories/30implementation/protocol-implementation-risk/#testing","text":"Code that is not tested is far more likely to contain bugs than code that has been tested. Comprehensive tests allow new features to be added without fear of breaking existing functionality. Hence, the more comprehensive the testing of the project, the less risky the project is. TODO: discuss continuous integration","title":"Testing"},{"location":"framework/20categories/30implementation/protocol-implementation-risk/#formal-verification","text":"Formally verified code should prove that the code matches the specification. Hence, formal verification can not detect bugs in the design of the project. However, it will pick-up implementation bugs that testing might miss.","title":"Formal Verification"},{"location":"framework/20categories/30implementation/protocol-implementation-risk/#documentation","text":"More documentation makes a project easier to analyze. A lack of documentation can lead to confusion and issues being missed. Projects that have good documentation are easier to maintain. Types of documentation a good project should have are: Architecture document that includes the component and deployment architecture. Thread model that includes all parts of the project. Sequence diagrams for all major data flows. Test plan describing how the project will be tested. Smart contract code comments at the contract and function level. Off-chain code with comments at the class and method level. Test code with at least a class level comment.","title":"Documentation"},{"location":"framework/20categories/30implementation/protocol-implementation-risk/#secret-storage","text":"Most projects use cryptographic keys to operate the system. These keys could be stored in a network HSM or a hardware wallet, and not in a file on disk on a server.","title":"Secret Storage"},{"location":"framework/20categories/30implementation/protocol-implementation-risk/#product-development-maturity","text":"TODO: Software Development Lifecycle (SDLC)","title":"Product Development Maturity"},{"location":"framework/20categories/30implementation/secret-storage/","text":"Secret Storage Most projects use cryptographic keys to operate the system. These keys could be stored in a network HSM or a hardware wallet, and not in a file on disk on a server.","title":"Secret storage"},{"location":"framework/20categories/30implementation/secret-storage/#secret-storage","text":"Most projects use cryptographic keys to operate the system. These keys could be stored in a network HSM or a hardware wallet, and not in a file on disk on a server.","title":"Secret Storage"},{"location":"framework/20categories/30implementation/testing/","text":"Testing Code that is not tested is far more likely to contain bugs than code that has been tested. Comprehensive tests allow new features to be added without fear of breaking existing functionality. Hence, the more comprehensive the testing of the project, the less risky the project is. TODO: discuss continuous integration","title":"Testing"},{"location":"framework/20categories/30implementation/testing/#testing","text":"Code that is not tested is far more likely to contain bugs than code that has been tested. Comprehensive tests allow new features to be added without fear of breaking existing functionality. Hence, the more comprehensive the testing of the project, the less risky the project is. TODO: discuss continuous integration","title":"Testing"},{"location":"framework/20categories/30implementation/upgrade/","text":"Upgradable TODO: This needs some thought. Upgrading can lead to rug-pulling, possibly by attackers who gain access to the address with upgrade privileges. However, code often has bugs. Additionally, new features can be added. Hence, the ability to upgrade is important. Are different upgrade mechanisms more and less risky? Transparent proxy Poor implementation where storage slots are mistakenly re-used has led to vulnerabilities. Deploy new contract and point front end at new contract. Non-transparent proxy with separate data contract.","title":"Upgrade"},{"location":"framework/20categories/30implementation/upgrade/#upgradable","text":"TODO: This needs some thought. Upgrading can lead to rug-pulling, possibly by attackers who gain access to the address with upgrade privileges. However, code often has bugs. Additionally, new features can be added. Hence, the ability to upgrade is important. Are different upgrade mechanisms more and less risky? Transparent proxy Poor implementation where storage slots are mistakenly re-used has led to vulnerabilities. Deploy new contract and point front end at new contract. Non-transparent proxy with separate data contract.","title":"Upgradable"},{"location":"framework/20categories/30implementation/verified-code/","text":"Verified Code on Etherscan All deployed contracts should have the source code uploaded using the Etherscan verified code tool, or similar tools for other blockchains. Not being able to determine what code have been deployed reduces the trust stakeholders have in the project.","title":"Verified code"},{"location":"framework/20categories/30implementation/verified-code/#verified-code-on-etherscan","text":"All deployed contracts should have the source code uploaded using the Etherscan verified code tool, or similar tools for other blockchains. Not being able to determine what code have been deployed reduces the trust stakeholders have in the project.","title":"Verified Code on Etherscan"},{"location":"framework/20categories/40operation/ability-pause/","text":"Ability to Pause If pausing is controlled by a multi-sig, then there is the risk that not enough parties can be gathered quickly enough to pause the project.","title":"Ability pause"},{"location":"framework/20categories/40operation/ability-pause/#ability-to-pause","text":"If pausing is controlled by a multi-sig, then there is the risk that not enough parties can be gathered quickly enough to pause the project.","title":"Ability to Pause"},{"location":"framework/20categories/40operation/decentralization/","text":"Decentralization of Operations Is there a single operator of off-chain components, or are many parties involved?","title":"Decentralization"},{"location":"framework/20categories/40operation/decentralization/#decentralization-of-operations","text":"Is there a single operator of off-chain components, or are many parties involved?","title":"Decentralization of Operations"},{"location":"framework/20categories/40operation/diversity-code/","text":"Codebase Diversity Is there just one implementation, or have multiple parties implemented the protocol?","title":"Diversity code"},{"location":"framework/20categories/40operation/diversity-code/#codebase-diversity","text":"Is there just one implementation, or have multiple parties implemented the protocol?","title":"Codebase Diversity"},{"location":"framework/20categories/40operation/offchain-security/","text":"Security of off-chain systems TODO (e.g. validators) Standard security practices such as ISO27001","title":"Offchain security"},{"location":"framework/20categories/40operation/offchain-security/#security-of-off-chain-systems","text":"TODO (e.g. validators) Standard security practices such as ISO27001","title":"Security of off-chain systems"},{"location":"framework/20categories/40operation/operational-security/","text":"Operational Security TODO: Discuss security posture and how is applies.","title":"Operational security"},{"location":"framework/20categories/40operation/operational-security/#operational-security","text":"TODO: Discuss security posture and how is applies.","title":"Operational Security"},{"location":"framework/20categories/40operation/protocol-operation-risk/","text":"Protocol Operation Risk Operational Security TODO: Discuss security posture and how is applies. Ability to Pause If pausing is controlled by a multi-sig, then there is the risk that not enough parties can be gathered quickly enough to pause the project. Codebase Diversity Is there just one implementation, or have multiple parties implemented the protocol? Decentralization of Operations Is there a single operator of off-chain components, or are many parties involved? Security of off-chain systems TODO (e.g. validators) Standard security practices such as ISO27001 Vulnerability Response Plan Is there a vulnerability response plan? Is there a methodology for deploying an upgrade prior to committing code to a public github repo?","title":"Protocol operation risk"},{"location":"framework/20categories/40operation/protocol-operation-risk/#protocol-operation-risk","text":"","title":"Protocol Operation Risk"},{"location":"framework/20categories/40operation/protocol-operation-risk/#operational-security","text":"TODO: Discuss security posture and how is applies.","title":"Operational Security"},{"location":"framework/20categories/40operation/protocol-operation-risk/#ability-to-pause","text":"If pausing is controlled by a multi-sig, then there is the risk that not enough parties can be gathered quickly enough to pause the project.","title":"Ability to Pause"},{"location":"framework/20categories/40operation/protocol-operation-risk/#codebase-diversity","text":"Is there just one implementation, or have multiple parties implemented the protocol?","title":"Codebase Diversity"},{"location":"framework/20categories/40operation/protocol-operation-risk/#decentralization-of-operations","text":"Is there a single operator of off-chain components, or are many parties involved?","title":"Decentralization of Operations"},{"location":"framework/20categories/40operation/protocol-operation-risk/#security-of-off-chain-systems","text":"TODO (e.g. validators) Standard security practices such as ISO27001","title":"Security of off-chain systems"},{"location":"framework/20categories/40operation/protocol-operation-risk/#vulnerability-response-plan","text":"Is there a vulnerability response plan? Is there a methodology for deploying an upgrade prior to committing code to a public github repo?","title":"Vulnerability Response Plan"},{"location":"framework/20categories/40operation/vulnerability/","text":"Vulnerability Response Plan Is there a vulnerability response plan? Is there a methodology for deploying an upgrade prior to committing code to a public github repo?","title":"Vulnerability"},{"location":"framework/20categories/40operation/vulnerability/#vulnerability-response-plan","text":"Is there a vulnerability response plan? Is there a methodology for deploying an upgrade prior to committing code to a public github repo?","title":"Vulnerability Response Plan"},{"location":"reference/ref/","text":"Reference The Crosschain Risk Framework builds on the authors experience in the crosschain and bridges space. We suggest readers new to the space consider the following works on crosschain communications. TODO","title":"Reference"},{"location":"reference/ref/#reference","text":"The Crosschain Risk Framework builds on the authors experience in the crosschain and bridges space. We suggest readers new to the space consider the following works on crosschain communications. TODO","title":"Reference"}]}